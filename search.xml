<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用 Travis CI 自动更新 GitHub Pages]]></title>
      <url>%2F2016%2Fpublishing-github-pages-with-travis-ci%2F</url>
      <content type="text"><![CDATA[每次更改完 NexT 文档 都要手动部署到 GitHub Pages，重复的次数多了就显得很麻烦，出错的几率也会变大。文档源码放置在 master 分支，最终部署文件在 gh-pages 分支。当在 master 分支更改某些内容之后，通过运行 gulp dist 来生成最终部署的 HTML 文件到 dist 目录，随后再进入 dist 目录初始化 git 仓库、添加文件、提交文件，最后将提交强制推送到远程 gh-pages 分支（因当心我会误将最终部署的 HTML 文件提交到 master 分支导致源码丢失，我在 GitHub 上把 master 分支给锁定了）。除此之外还有另外一个问题：如果 master 分支有 Pull Requests，我需要先将更新取回本地，然后编译更新再提交回远程 gh-pages 分支。 年轻的想法于是，我就想这说将这个过程自动化。首先考虑了使用 GitHub Webhooks，这是 Github 提供的一种机制，使应用能与 Github 通讯。这种机制实际上就是 Pub/Sub，当 Github 监测到资源（如仓库）有变化就往预先设定的 URL 发送一个 POST 请求（Pub），告知变化情况，而后接收变化的服务器（Sub）即可做一些额外的事情。 这个思路需要有一个服务器并启动一个服务来接收 Github 的请求。这里又有种不同的策略，这两种策略都是基于源码放置在 Github 的前提。第一个是源码将最终文档直接部署在这台服务器上（如使用 Nginx），当接收到 Github 通知直接编译更新到服务器指定的文件夹下即可。另一种策略是当服务器接收到通知后编译更新，而后将编译后的版本提交到 Github 仓库的 gh-pages 分支，让 Github 做 Host。 Travis CI 登场由于比较穷，租不起服务器（果然有点年轻），于是就想说有没有免费的方案可以用。于是就惦记起各种 CI 服务，本着够用就好少折腾的原则直接选了 Travis CI，对外宣称是免费的还要求那么多不是太合适，其实本质是读英文文档嫌累π_π。没有折腾精神的开发不是一个好开发，这能怪我么，好吧，确实是我的错，我太穷了。 那么，终归是找到了解决方案。有了持续构建系统，就可以做到有更新自动 Build，意味着就可以多看两集韩国噢八剧，一集英国基情剧，N 集日本爱情剧以及英雄联盟。那么预想的整个流程就是 ： 更新代码到 Github Github 跑去告诉 Travis CI 说有个东西变了 Travis CI 勃然大怒、立马安排 Build Travis CI build 成功后，将输出丢到 Github gh-pages 分支 Github build Pages 领盒饭收工 非常 Easy，哪里不会去 Google！ 那些年的那些坑接下来就是实际动手了。注册 Travis CI，Github 集成 Travis CI ，Travis CI 为特定的仓库变动自动 Build 这些事情就是像个 Boss 一样点点鼠标就行了。问题就在于最后一步，怎么让 Travis CI 往 Github 提交代码呢？将 Github 帐号信息写在 .travis.yml 文件里毕竟是一个太过年轻的做法。然后我找到了 Hexo 作者 SkyArrow的这篇文章，通篇看下来，我长嘘了一口气在想要不就老老实实手动编译更新吧。然而，就在我长嘘短叹人生之艰难的时候，突然发现 Travis CI 除了支持 加密文件 也支持 加密 Token Key。于是，事情有了转机。 另一种方案这种方案不再使用 RSA 加密算法去生成一对密钥，取而代之的是 Github 提供的 Personal Access Token。这个 Token 与 帐号密码 以及 SSH Keys 同样具有 Github 写入能力，因此只要使用 Travis CI 提供的加密工具来加密这个 Token 即可。 方案原理根据 Travis CI 的文档，他会使用一对 Key Pair 中的 Public Key 来加密你提供的 Token 得到一个 Secure Token（这个 Secure Token 可以安全地放置在 .travis.yml 中），而在 Build 的时候他会使用 Private Key 来解密这个 Secure Token 获取最初提供的 Github Personal Access Token，见下图： 具体操作了解了背后的原理就可以大胆地去着手实现。按照原理来讲，大致需要三个步骤，第一获取 GitHub Personal Access Token；第二使用 Travis CI 的工具加密这个 Token，并保存到 .travis.yml 文件中；第三配置文件使用 Access Token。具体的操作步骤如下： 生成一个 Github Personal Access Token。前往 Github 帐号 Settings 页面，在左侧选择 Personal Access Token，然后在右侧面板点击 “Generate new token” 来新建一个 Token。需要注意的是，创建完的 Token 只有第一次可见，之后再访问就无法看见（只能看见他的名称），因此要保存好这个值。 使用 Travis CI 的 命令行工具 加密 GitHub 的 Personal Access Token。这个工具是一个 gem 包，因此需要 Ruby 环境。假设已经安装好 Ruby 环境，即可安装 Travis CI 的命令行工具，以及加密： 12345# 安装 Travis CI 命令行工具gem install travis# 加密 Personal Access Tokentravis encrypt -r iissnan/theme-next-docs GH_TOKEN=XXX 第二条命令中 -r 后的参数是 GitHub 仓库的名字（&lt;用户名&gt;/&lt;仓库名&gt;）；GH_TOKEN 将作为环境变量使用。将这条命令输出的结果复制到 .travis.yml 文件下： 1234env: global: - GH_REF: github.com/iissnan/theme-next-docs.git - secure: "XXXXXX" 这个设置之中包含了 仓库的地址（设置在 GH_REF 环境变量中）以及 Access Token （被加密了，设置在 GH_TOKEN 环境变量中）。这两个环境变量将 Build 的时候被使用，用于往 GitHub gh-pages 分支推送。 让 Travis CI 往 Github 仓库的 gh-pages 分支提交。根据需求的不同，这里的配置也不尽相同，但重要的是如何使用 GH_REF 和 GH_TOKEN 这两个环境变量。NexT 文档是执行 gulp dist 来生成最终的 HTML文件，然后推送到 GitHub Pages，其配置如下： 12345678910111213141516171819# S: Build Lifecycleinstall: - npm installbefore_script: - npm install -g gulpscript: - gulp distafter_script: - cd dist - git init - git config user.name "iissnan" - git config user.email "email_address" - git add . - git commit -m "Update docs" - git push -f "https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;" master:gh-pages# E: Build LifeCycle 到此，整个流程就结束了。NexT 文档使用的配置在 这里，有需要的可以参考下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NexT Documentations Reload]]></title>
      <url>%2F2016%2Fnext-documentations-reload%2F</url>
      <content type="text"><![CDATA[尽管简单易用一直是 NexT 主题的首要目标，但现实与想法总是有那么一个缝隙，难怪有人说诗要源于生活后低于生活，着实有着深刻的哲学道理。那么无论这背后是什么样的原因导致，总结起来就是 NexT 不好用。在初期使用者比较少的情况，还可以有耐心的一个个解答；后来发现一直在回答类似的问题，加上要做和想做的事情太多而无暇顾及，于是就想写一份文档缓和一下这个问题。 前季剧情回顾起先，我使用 Hexo 搭建了第一版的 NexT 使用文档站点。UI 框架选择的是 Semantic UI，并且新建了一个主题称为 Luminosa。然而我发现要在 Markdown 里使用 Semantic UI 的组件有点麻烦，以及 Hexo 在解析 Markdown 时会自动加上很多空行的问题。不得已之下，只能创建了几个 Tag Plugins 封装了一下使用到的 Semantic UI 的组件。 这也就解释了为什么在使用了 Semantic UI 的情况下，整体界面依然如此的粗糙与潦草，因为我把时间都花在写 Plugin 上了。至于文档的质量，早就被忘记在春天的田野里了。夏天是个愉快的季节，毕竟是 Sunshine 与比基尼同在的日子，文档的事情就别提了（我记得有一位热心的用户曾给 Docs 发过一个 PR，我没有 merge，在此说下抱歉）。然而时间就是个无情的戏子，夏天的风景还没看够就火急火燎地带来了秋天。秋天是文人墨客各领风骚的季节，到处是寂寞与沧桑，就在这样一个浮躁的季节里，我回头看了下文档，深刻地意识到只有呵呵能表达我对自己直触灵魂的佩服。 短期计划乱入那么，经过一个工作忙碌周期后得已有些空闲时间，就把最近的空闲时间花在重新制作与编写 NexT 文档。目前的计划是，近期发布一个 Release 出去，版本号从 0.4 直接升级到 5.0.0（紧随 Facebook 大法脚步）。这个 Release 主要包含的是 Pisces Scheme ，修复 Pisces 引入的 Bug 以及更新文档。在此以后应该有一个小的更新，主要解决 Issues 里反馈的 Bug。再下一步是侧栏的重写，以及图片展示（这玩意一直搁着）。短期计划差不多就这样。 文档的重装上阵说回文档。有了第一版的经验，第二版就决定不再使用 Hexo 了。在 Markdown 里写大段的 HTML 代码，干脆就直接写 HTML 代码好了，除了要多写一些结构性标签以外（其实很多），写 HTML 还是比较直接。这样得到的好处是内容层比较好控制后，外观和行为也就没有什么障碍。 第二版选择了 Bootstrap 作为 UI 框架，使用 Nunjucks 模板引擎，Sass 预处理语言以及 Gulp 构建工具。起初技术栈没这么有档次的感觉，我只想好好的写份文档，但到写第三个页面时，实在受不了了每次都要复制头尾相同的文档内容，这万一要改下这公共的内容，那就不能好好的写文档了。 于是就引入了 Nunjucks。而使用一个模板引擎的话，就得解决从模板生成页面的问题，这个问题包括开发过程以及部署代码生成过程。幸运的是，这个问题并不难。使用 Nunjucks 的 API 生成一个 Renderer，而后这个 Renderer 可以用在 BrowserSync 的中间件中以及 Gulp 的部署生成任务中。顺利地解决了模板渲染的问题。所以，文档绝大多数内容都是 HTML 代码，唯一的例外是代码片段。考虑到在 HTML 中书写 HTML 源代码要对大量的 &lt; 以及 &gt; 做转换，所以我增加了一个 code 的标签，用来快速的插入代码片段。 插个广告，安利下 BrowserSync 这个神器，自动刷新、多设备同步、中间件支持、Proxy 支持，真是前端开发必备神器，谁用谁知道。我曾在一个项目中使用 Grunt 做双重 Watcher，第一重 Watcher 用于监听源码的改动并生成预部署的代码；第二重 Watcher 监听预部署的代码并部署代码到应用程序容器下。使用 BrowserSync 后只要一个 Watcher 加 Proxy 即可轻松解决这个场景的需求。自从用了 BrowserSync，感觉一下子年轻了好几岁，爬楼都有劲了（超过时的广告文案）。 大体框架搞定后就是文档内容了。我花了点时间重新润色了下当前已有文档的内容，争取把每一个点都详细的写明，目前仍在继续撰写中（「撰写」这个词很有力度，直接表明了写文档的难度系数极高）。然后发现 NexT 包含了很多特性，有些我也没有在使用。所以如果你有看到有遗漏的不妨访问 NexT 文档发个 Issue，或者 Pull Request 更赞。 .next-documentations-reload-help-button{ ;padding: 0 20px; ;border: 2px solid #555; ;text-decoration: none; ;display: inline-block; ;overflow: hidden; ;color: #555; ;font-size: 14px; ;background: #fff; ;border-radius: 2px; ;transition: all 0.3s ease; } {}.next-documentations-reload-help-button:hover { ;color: white; ;background-color: black; ;border-color: black; } {}.next-documentations-reload-help-button i {margin-right: 5px;} 访问 NexT 文档 NexT 文档源码 最后的最后，请不要在文档仓库提交 NexT 主题相关的 Issue，只接受文档相关内容，蟹蟹。 夜深了，洗洗睡，回头再念叨。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记近期电脑设备升级一事]]></title>
      <url>%2F2015%2Fupgrade-computer-components%2F</url>
      <content type="text"><![CDATA[十一月真是一个忙碌的季节，电商平台携商家精心布局撒网等鱼入网，买家手握巨款蠢蠢欲动，物流赶忙提升内容分发系统的高效性与健壮性，一副生机勃勃的画面。作为不怎么热衷购物的我在这番阵势下也激动的跃跃欲试，为了做好热身运动，我提前升级了下电脑设备。那买买买的节奏可谓十分轻快明朗，让人欲罢不能。钱要花在刀刃上，这是我获得的人生的第二条真谛，还挺早获得的，就是执行力不够。我把这个错误归结为冲动的欲望在作祟，但很明显是自我欺骗，显然应该怪商家太会营销打广告。 常话说的好，高富玩表，土豪玩车，屌丝玩电脑。作为一名屌丝中的战斗机，那电脑必须玩得溜。人生真谛第三条，既然决定做一件事情，就把这叫事情做好，无关贫富贵贱，此乃工匠本色。看着那些陪伴多年，依然坚守岗位默默奋斗的电子设备，我想是时候了，是时候来个咸鱼翻身，再扑腾一阵子。 第一件物品 SSD。早有耳闻说 SSD 如何如何的快，快到足够让旧设备重新焕发青春。这对于没有钱买新 MacBook Pro 的我来说，简直是福音。市场上 SSD 产品可谓琳琅满目，各有各的特色，加上各路神仙尽显巧舌之簧，这无疑对作为资深选择困难户的我是一种巨大的挑战。在咖啡提神，两眼放光如狼似虎的地毯式搜索以后，我选定了两个品牌：浦科特与英特尔。为什么选这两个，这其中的细节可以再写一万字，不再赘述。最后，英特尔 战胜了 浦科特，装逼还是得 Intel inside。 就在我为自己的英明抉择佩服不已的时候，剧情发生了 360 ℃ 反转。猴急猴急测试 SSD 性能的时候，我发现我那款 MacBook Pro 只有 SATA 3GbitS，这意味着要降低将近一半的速度在跑。早知如此，何必买那么好的，耽误人家 SSD 的青春。犯下如此低端错误，实在有丢我高端风格的脸，为此我忧伤颓废了 72 小时。为了治愈这直触心灵的创伤，我把注意力转移到了显示器上。 2009 年夏秋交换之时，我买了一台 Dell 22 吋的 UltraSharp 2208WFP。而随后几个月似乎大屏液晶显示器价格开始下滑，尽管如此，我还是觉得当时买这台显示器是很正确的选择。在此之前使用的是那种很笨重的纯平显示器。在点亮 2208 显示器的那一刻，我眼泪禁不住留了下来，这要早点买，说不定我代码就不会写那么差了。不过，后来事实证明，这两者之间没有太大的关系，因为我都用这个显示器去看 火影村忍者的搞基历程 和 王路飞当海贼 的连续剧了。从 17 吋 1024 x 768 的分辨率升级到 22 吋的 1680 x 1050 ，那效果还是相当震撼的。所以，对于购买显示器我已然有一个黄金标准，就是屏幕要大，分辨率要高，其他的不重要（商家就喜欢我这种用户）。 鉴于 2208 仍在服役，我对 Dell 的质量还是很放心，所以这次依然购买了 Dell，型号 U2515H。为了掩饰更高级的买不起的事实，我把 U2515H 的优点放大了 2515 倍，什么字距小容易眨眼之类的描述一概忽略，买的心安理得。只是在 Dell 官网购买的过程有点小波折，那酸爽体验岂是三言两语能言尽。那是一个复古风 2000 年左右的互联网网站。我一路过关斩将、千辛万苦到达付款页面，最后跪在了使用信用卡付款的路上，世上竟然有如此套路复杂的支付招式，在下跪的心服口服。庆幸的是，还有支付宝可以便利地付款，虽然我不用支付宝。 注册帐号，付完款之后发现账户页面找不到任何订单。在 Google Chrome 浏览器下还一直发生“此页面包含循环重定向” 这种不明所以的错误。这种时候，我想到了 IE 浏览器。哎？真的可以哎，原来 IE 除了制造各种疑难杂症，还会治，双 Zhi 齐下。这让我对 IE 的印象完全改观，然后继续用 Google Chrome。至于这个问题背后的黑科技我就暂时忽略了，买台显示器的时候买到后面在查 Bug 显然有点太专业了（代码写的不好看来跟这个态度有关系）。但是，迷之订单迟迟没有出现。 好吧，既然如此，我再等三分钟看看。好吧，既然如此，我就再等三十分钟好吧，既然如此，我就再等三个小时。 好吧…作为一名每天堆砌文字符号兼复制粘贴的软件工作者的我相当的不淡定了，你们这么弄真的好吗？我只是想买一个显示器啊，我为了便宜两百块不上京东买我就错了吗？然后，我收到了邮件，一查原来 Dell 有这种线下销售的模式。被其他电商长期溺宠的我表示很不习惯。订单没法看，物流没法查，那种翘首以待的购物乐趣何在呢？庆幸的是，从下单到收货，只用了三天不到。原来 Dell 是要给我惊喜，呵呵。 到货后，依然猴急的拆箱装上。网上很多拆箱晒照，我想应该有免费的可以借用吧（请尊重原创）。所以那张照片不是我拍的（出处）。迅速接上 MacBook Pro，自带 Mini DisplayPort - DisplayPort 的线正符合条件。可以啊，这下代码水平又能提高不少了，然后点开了 《千与千寻》，真是百看不厌的名作啊…哎？试试 LOL，会不会视野更开阔些，不容易被 Gank 呢？嗯，代码什么的有时间再说吧… 屏幕大了，设备速度快了，然后硬盘容量不够了。一部电影就好几个 G，SSD 那么点容量分分钟被撑爆。听说拆光驱换硬盘这套狸猫换太子的手法可以扩容，我就去淘宝买了一个光驱支架。对于一个为折腾而生的人来说，替换光驱支架那都不是个事。换了以后，把一些只能在三更半夜夜深人静的时候看的东西，果断移到了机械硬盘上。 如此一番，除了荷包渐瘦以外，其他都到位了。那么，热身完毕，就等双十一开战了。战场上见。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊聊 NexT 主题]]></title>
      <url>%2F2015%2Fsomething-about-next%2F</url>
      <content type="text"><![CDATA[NexT 主题 快满一周岁了，值此之际，碎碎念一下（没有干货）。正如我在 V2EX 分享 时的介绍一样，NexT 的前身叫做 Notes。在做 Notes 主题的时候，基于当时的需求出发点，从好听上来讲是简洁，不好听就是简陋（真直接，脸红）。 Notes 开发于我刚接触 Hexo 时。当时我拥有一个基于 WordPress 的独立博客，这个博客主要用来写比较完整的技术类文章。在拖延症与技术挫的主观加客观因素综合作用下，这个独立博客也是产出寥寥。然而在丑小鸭能变美丽天鹅的唯美段子的安利下，我也是每天勤勤恳恳钻研技术（折腾不休）。每日阅读各路教程，搜索各种解决方案，追根溯源探索背后的原理，企图从根本上回答 “我是谁？我从哪里来？我要到哪里去？” 这类哲学问题。 在探索人生真谛的路上，为了防范捡了芝麻丢了西瓜这种愚蠢的问题，我果断想出一个方法，就是找个东西记下来。为了体现出折腾的本性，云记事本那根本不入法眼（要用也得自己开发，哎哟，很屌哦），然后又毙了 WordPress 独立博客，纯粹因为静态博客很火。那么，说好的以记录为主的目的丢到哪去了呢？ 总之，结果是我折腾了 Jekyll、OctoPress，最后落在 Hexo。作为选择困难户在选择静态生成博客的时候能够如此果断，那必然是因为只能选择会用的… 无论如何，使用 Hexo 还是挺顺手的，这里不得不夸下 Hexo 的整个代码设计很赞。但问题是我用了一圈就没一个对的上眼的主题。我要的其实很简单啊（遇到说这种话的客户，请直接拒绝，不要问我为什么），只要显示文章内容就好了啦，不要侧边栏啦，不要社交啦，最好字体好看点，排版优美点，颜色搭配舒服点，整体大气点，访问速度快一点，动画特效多一点。于是就有了 Notes（果然记录什么的这种事情不重要）。 嗯，基本上就长这样，明显我自己还是比较好忽悠的，这没有一个点能匹配的上啊！（竟然只有两个 Release，不思上进也得有个度啊）。那么，Notes 使用了 Jade 作为模板语言，其实还是大量参考了 Hexo 自带主题的模板结构，只是从 EJS 做了一次迁移。模仿是学习一件东西的最好开始（我最喜欢这种美丽的借口）。样式预编译语言是 Stylus，小众，我喜欢，尽管坑不少。Notes 里有几个功能在 NexT 中延续了下来。比如说 程序员 最爱的换代码主题，博主最爱的换主题皮肤（可以考虑学 LOL 做皮肤收费）等等一系列功能（其实也只有这两个）。总的来说，作为先锋，Notes 立下了汗马功劳。 一个突然的深夜，在一顿好生虐待键盘后。我来到了阳台烧起一根香，思考着如果把租用虚拟主机的钱用来抽更好点的烟这个疯狂的 idea。为了证明抽烟也可以省钱这个不切实际的想法，我果断停掉了 WordPress 独立博客。然而，在迁移在 WordPress 上原先那些无聊的文章，烦的把租用主机的费用都抽掉了。而 NexT 便是诞生于此之间。 NexT 在 Notes 的基础上做了大量的改动。首先是使用 Swig 将原先的 Jade 模板完全替换掉，对于记忆力不行还很懒的我来说，使用 Swig 还是比较接近 HTML ，好记易用不费力。 然后无聊企图用 Sass 替换 Stylus 没有成功，所以还是 Stylus 继续耀武扬威。之后，在每一个版本中都加入一些常用的功能，让她更普遍化。 在制作 NexT 的过程中，第一要素是保证其易用性。如果一个功能超级炫丽，但难于使用，那宁可不做（真是漂亮的借口）。这一点可以追溯到偶像诗人白居易，他的诗可以通俗到妇孺皆知，确实有一定手段。那么 NexT 目标亦即如此，谨慎对待自己使用都觉得麻烦的功能。比如说，自定义 Icon Font 这个功能，其实我自己都觉得修改很麻烦，所以一直想把这个功能去除掉（在最近的一个版本中，我终于克服拖延症把它给去掉了）。 偶然一次看到了 苹果广告 视频里那个动画效果，羡慕嫉妒爱，于是就谋划着给 NexT 加上动画特效。本着本土流氓也要有国际黑帮气质的精神，我制作（抄袭）了许多个动画效果，后面都回滚掉了，着实可惜，此处没法装逼，自有装逼处。无论如何，结果是 NexT 加上了一些让浏览器抱怨不堪的动画效果，这完全是 VelocityJS 这个动画库的错。 日子就在花式拖延以及不负责任的抓 七星瓢虫 中悄悄流逝。又是一个凉如水的深夜，我把原先 Notes 中替换皮肤 （Scheme）的功能搬过来，并将其流水线化，利于多套 Scheme 的开发。说到 Scheme，基本原理就是给同一套 HTML 结构应用不同的样式，以达到不同的外观。 结合预编译样式语言，理想情况下，只要更改样式变量即可解锁不同的外观（收费皮肤的基本功）。那为什么不分开做成不同的主题呢？因为那不好玩（这逼装的可以）。贪玩的结果就是，三更半夜还在写作业，这是我获得的第一条人生真谛。由于 Scheme 之间需要共用一些内容，包括 HTML，CSS 以及 JavaScript 这三个闻名于世的贱客。这就需要设计一套良好的机制来降低开发与维护的成本，而这正是 NexT 所欠缺的。所以简单来说，三套 Scheme 加上各自的 Mobile 版本，也就意味着一次修改需要测试六个版本。 然后有了 Mist Scheme。如果不是我错觉，这款皮肤更受欢迎（果然收费皮肤有潜在的市场）。作为 NexT 第一款 Scheme，Mist 还是不负所望，如同夏日傍晚操场吹过的凉风，激起了一片裙子，噢，不是，秀发的飞扬（神马牌主题，宅家写博客常备良品）。 尽管没有一台单反设备，但这并不妨碍我想给 NexT 添加优雅地展示图片的想法。而这个过程一直不顺利，因为在易用性上确实很让人却步。遇到不顺的事情，拖延症就发作这种事情我是不会到处乱说的。就在最近，放着一堆 Bugs 没抓的前提下，我又开坑写了一个新的双栏皮肤（说好的暗色 Scheme 呢）。那么，这款皮肤称为 Pisces，目标是清秀。嗯，只能说这么多了，说太多易食言（其实只想到这么多）。 就念叨到此吧。前路漫漫，后会有期。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[group-picture-test]]></title>
      <url>%2F2015%2Fgroup-picture-test%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS 应用单元测试起步]]></title>
      <url>%2F2015%2Fangularjs-application-unit-testing-getting-stated%2F</url>
      <content type="text"><![CDATA[AngularJS 很重视测试，所以提供了很多特性使得编写测试变得更容易。AngularJS 应用的单元测试与普通的 JavaScript 应用测试有些不同。 AngularJS 应用是以 module（模块）为单位来组织应用，将不同的功能放进各自的模块。测试可以从整个应用级别，或者从特定的模块开始。正是由于测试可以从模块开始，在测试的时候需要指定引用的模块。 AngularJS 应用在启动的时候，会寻找 ng-app 指定的模块，而后创建一个 $rootScope 以及一个管理依赖的 $injector，而后依赖将通过 $injector 自动注入。在测试的时候，需要手动处理这个过程。因为在编写测试的时候，希望的是能够进行单元性的测试，能够针对特定的模块进行测试。所以在编写 AngularJS 测试的时候，我们需要手动去引用某个模块 ，同时手动创建 $rootScope 和手动引入依赖。 AngularJS 提供了 ngModule 这个模块，包含一些方法用来处理这个过程。这个过程主要使用到的是两个方法，分别是 module 以及 inject 方法。前者用于引入模块，后者用于处理依赖。例如： 12345678910111213141516171819describe('type: name', function() &#123; var $scope, myService, $location; // 在每个测试用例执行之前，引用 app 模块 beforeEach(module('app')); // 在每个测试用例执行之前，注入依赖 beforeEach(inject(function($rootScope, _myService_, _$location_) &#123; $scope = $rootScope.$new(); myService = _myService_; $location = _$location_; &#125;)); it('should work', function() &#123; // Do something // Expect something &#125;);&#125;); 示例代码来自 Angular Tips 有一点要注意的是，在 inject 方法内，有两个参数都有前后的下划线，这个下划线实际上是为了便于编写测试（使得测试内局部变量与依赖一致的名字），AngularJS 会忽略这前后下划线，并找到对应的依赖。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[希桅的第一次面试]]></title>
      <url>%2F2015%2Finterview%2F</url>
      <content type="text"><![CDATA[路上车来车往。“红灯停绿灯行，这个世界能够一致的规则貌似不多”，希桅望着车窗天马行空的想着。 世界需要规则，但同时又不能完全遵行规则。这本身就是一件多么矛盾的事情。中庸之道只是一个结论，这个结论的推进过程估计充斥着各种矛盾的上下波动。时期不同，环境不同，心态不同。同样的条件背景，有人追求本质极致，有人追求无为而治。微观变数聚集而成宏观不变。 希桅是一个乐观主义差不多派，他的乐观也是差不多的。这个时候，他正在车上，去往一场面试。在车上他胡乱的想着一些不着边际的事情，完全没有为接下来的面试考虑。希桅虽然性格优柔寡断，但他有船到桥头自然直，以及抱佛脚不够优雅两个护盾驱使他表现的有那么点从容。 学校的课希桅仅上了开学第一节，领了新书后再没有踏过教室的门。既然闲着也是闲着，于是他决定出去找份工做，今天正是他的第一次面试。与往常一样，他睡到快中午。然后草草地洗过，草草地吃过被忽略的早餐，然后悠然地出发。坐公车对他来说是一件愉快的事情，在公车上他可以无聊地想一些无聊的事情来打发无聊。 准时一词绝对不能用在希桅身上，而今天他意外的提前到了面试的公司。想来，第一次面试对于他来说还是比较重大的。接待他的是一个年轻的女孩，估计二十来岁，给希桅引到一间办公室并倒了杯水就此消失不见。 十月份的这个城市依然到处是短袖短裤。“坐在这带有空调的办公室多少比宿舍吹风扇舒服”，希桅想着，然后对这里产生了那么一丝好感。几分钟后，一位看起来十分年轻的男子出现在会议室，手上拿的就是希桅的简历。穿着看似十分简单，却不乏气质，左手带着一条檀木珠子和一个看上去价格就不菲的手表。 “你还没毕业？” “嗯，今年大四。明年毕业。” 男子眉毛皱了一下，不知道是针对希桅还没有毕业这件事情本身，还是对于他们招聘专员的选择。 “学校应该还有课吧？” “还有，上腻了。” 希桅回答的出乎意料的直接。“听老师为履行职责而在课上念书实在没多少意思。” 听的出来，希桅对于他们学校的教学心存抱怨。初生牛犊不怕虎。 “你觉得你现在的能力可以胜任这份工作吗？” 年轻男子虽然说话柔和，但句句直指问题重点。 “我想可以。” 希桅不知道哪来的自信。 … … “OK。请稍等。” 年轻男子走出会议室，表情依然跟进门时一样的不动声色。持续将近半小时的谈话中，没有涉及任何专业方向的问题。这让希桅有点忐忑。他只能猜测年轻男子是 HR 来安慰自己。 大约三分钟过后，希桅被年轻男子带去另外一间办公室。办公室里坐着一位中年男子。“看上去很有震慑力” 希桅看到中年男子后的第一想法。年轻男子介绍了一下，然后带上门出去了。 “你好” 希桅打开了接下来谈话的开头。这次谈话的范围比刚才的广了许多，希桅还是一如既往的直接。在此之前，他就已经想过，对于像他这种如同白纸的学生，与其畏畏缩缩掩掩捂捂，不如坦荡直接。谈话结束后，希桅对中年的最大印象是他洪亮的声音以及平和语气后那股震慑力。 面试意外的快速并且顺利，他可以选择接下来一周的任何一天去上班，或者说实习。作为还未毕业的希桅来说，这次面试能够如此顺利，很多成分可以归结为对的时间，对的场所。简单来说就是缘分。 面试结束后将近下午四点钟，外面依然热哄哄的。他走出办公楼，伸了个腰，作为面试这一件事告一段落的仪式。他走到十字路口边的公交车站，想着宿舍有几本图书馆借来的书到底超期多久了这个问题。然后，他继续检视身边还有几个类似一直堆积的问题。尽管是小波动，但这对希桅来说他如同站在人生的十字路口旁的公车站。 唯一不同的是，这辆车不知道开往哪里。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于如何写作的知乎问答]]></title>
      <url>%2F2015%2Fquestions-in-writing%2F</url>
      <content type="text"><![CDATA[如何写出 信手拈来、惊鸿一瞥、深入其境、欲罢不能 等等等等的文章？ 对于新手来讲，写小说要做好哪些准备？ 新手写小说常会陷入哪些误区？ 什么叫做文字的张力？ 如何把人物写得立体？ 如何用 150 字写出一个让人欲罢不能的开头？ 作家都是如何提高构思能力的？ 如何写好一部小说的情色部分？ 怎样才算文笔好？ 怎样提升一个人的文笔？ 写作过程中如何控制节奏？ 如何创作一个多线叙事结构？ 扩展视野，乔老爷的脑洞： 为什么明知道故事是编的，人们还是那么在乎结局？ 怎样将《喜羊羊与灰太狼》写出《冰与火之歌》的感觉？ 有哪些美哭你的句子？ 你看过文笔最美的书是什么？ 如何把平常的事物写出恐怖的感觉？ 集大家之成，悟小家之道。取法乎上，得乎其中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[十年]]></title>
      <url>%2F2015%2Ften-years%2F</url>
      <content type="text"><![CDATA[昨日之事已在风中冷却，明天的回忆会不会被忘却？我想在这黑暗的城市上空飞行，看看灯火里别人的故事是否也如此的彷徨？ 千家灯火万家难。望着他人的幸福，徒生向往；注目他人的难处，油然怜悯。他们时而欢笑，时而落泪。因为小事而倍感幸福，因为小事而万分感伤。 那些绽放如花的笑容，那些泪洒如雨的忧伤，都随着时间的流逝或被遗忘，或被掩藏。万物皆无法摆脱时间的摆弄。时间是一个随意的雕刻家，雕塑着一幕幕的喜怒哀乐。 落寞一幕无人视，繁华一曲谁人听。半生浮萍，一世漂泊，肝肠寸断，所为几何？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[车站]]></title>
      <url>%2F2015%2Fstation%2F</url>
      <content type="text"><![CDATA[希桅的性格是犹豫柔断型的。这一天是周日，他与月杉走在人来人往的车站附近。他们手牵着手漫无目的的走着，周边都是匆匆忙忙赶车的人群。他们缓慢的脚步使得他们与周围人群格格不入。 这已经不记得是第几个他们两人的周末。他们在这个二级城市里念大学，但是两所大学之间还有着将近两个小时的车程。每个周末他们都早早的出来相聚，走遍这个城市中心的每个角落。尽管每次都走上一整天，直到走的脚都麻了，但对于他们来说是幸福无比的。 周日的下午，他们徘徊在车站附近。希桅在这个车站送月衫坐车回学校。在离别的时刻，他们的话开始变少。时间在一秒一秒的流逝，他们的不舍在空气中慢慢的扩散。说回来，这真是一个奇怪的事情，当时间越是有限，他们之间的话语越是稀少，仿佛多说一句话就会将他们的不舍完全的吞噬，于是只能以这种特殊的形式来面对接下来的分离。尽管下周他们依然可以再次见面，但这一周对于他们来说如同一年那么的长久。 在他乡异地，他们相依偎在一起。在他人眼中，他们是再平凡不过的一对情侣。而对于他们来说，对方都是对方的全世界，这气候的他们没有羁绊，如同在广阔草原上的马群，无拘无束。 时间如滴水，暂离的时间来临。月衫回学校的最后一班车终于准备发车。留恋在此刻升华，随着车的越驶越远而加深。 当月衫的车驶离希桅的视线后，希桅转身走出车站，搭车回他的学校。在车上，他们各自开始回忆着这个周末的点点滴滴，如同在回味着刚吃完了的糖果，满满的都是甜味。然后靠着这些余味等待下一个周末的重逢。 尽是如此，如若两颗星星，天各一方，遥遥相望。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[言轻语长]]></title>
      <url>%2F2015%2Fcroon%2F</url>
      <content type="text"><![CDATA[当意识再次醒来时，过去如同山崩之流，倾泻而来，将萌芽的光线拖入无尽的黑暗之中。挣脱之后，恍如昨日，一线之隔，南为乾坤，北为虚无。 一把岁月，无尽悲伤，聚散离合皆付风中。不曾相遇，何曾相识；不曾相识，何曾相知；未曾相知，遑论感伤。如若初遇，不如不遇。于世之最大谎言在于问心无愧。 风来雨去，日落月升，蓦然回首时物是人非。虚度彩练当空，徘徊庭树遍绿，长叹夕阳沉暮。不言问心无愧，只许一纸墨迹。 言轻轻待摆渡，语长长候倾听。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactJS 快速入门]]></title>
      <url>%2F2015%2Fgetting-started-reactjs%2F</url>
      <content type="text"><![CDATA[React 是近期非常热门的一个前端开发框架。 这篇文章将介绍如何使用 React 来创建用户界面，希望能够起到抛砖引玉的效果。 相对于其他框架来说，React 提供了非常少的 API， 如同 Gulp， 越是少量的 API 同时意味着越多的可能性。 正如那句名言所说： Less is more. 但是，精简的 API 不是意味着没有一定的学习成本，我们还是需要对此框架进行一定的理解。 闲话不多说，让我们进入正题。首先，让我们来了解下 React 中使用到的一些术语。 React 术语 术语 解释 React Elements 代表 HTML 元素的 JavaScript 对象。 这些 JavaScript 对象最后被编译成对应的 HTML 元素 Components 封装 React Elements， 包含一个或者多个 React Elements。 Components 用于创建可以复用的 UI 模块，例如 分页，侧栏导航等 JSX JSX 是 React 定义的一种 JavaScript 语法扩展，类似于 XML 。 JSX 是可选的， 我们完全可以使用 JavaScript 来编写 React 应用， 不过 JSX 提供了一套更为简便的方式来写 React 应用 Virtual DOM Virtual DOM 是一个模拟 DOM 树的 JavaScript 对象。 React 使用 Virtual DOM 来渲染 UI， 同时监听 Virtual DOM 上数据的变化并自动迁移这些变化到 UI 上 DEMO 环境准备首先，在 React Download 页面 下载 Starter Kit，解压到某个地方。 进入到解压后的 build 目录，新建一个 index.html 文件，并且引用 react.js 和 JSXTransformer.js 后就可以开始编写 React 应用了。需要注意如果使用 JSX， 那么 script 标签的 type 应该更改为 text/jsx。 12345678910111213&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" &gt; &lt;title&gt;demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="react.js"&gt;&lt;/script&gt; &lt;script src="JSXTransformer.js"&gt;&lt;/script&gt; &lt;script type="text/jsx" src="app.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 第一个 React Element创建一个 Element 只需调用 React.createElement 方法，并传入元素信息即可。例如： 1234var div = React.createElement('div', null, "Hello React");// 使用 JSXvar div = &lt;div&gt;Hello React&lt;/div&gt; 创建之后就可以调用 React.render 方法渲染到页面上： 1React.render(div, document.body); 第一个 React ComponentReact Component 抽象出相同 UI 组件的结构和逻辑。 通过调用 React.createClass 方法来创建一个 Component，并传入一个带有 render 方法的对象类型的参数。 1234567var HelloMessage = React.createClass(&#123; render: function () &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);React.render(&lt;HelloMessage name="iissnan" /&gt;, document.body); 我们看到 React.createClass 接收了一个对象，并将这个方法返回赋值给 HelloMessage， 最后调用 React.render 方法将这个新建的 Component 渲染到页面上。从这个例子看来，一个 Component 与 Element 并无太大的差别。 事实上， Component 已经准备好了，我们可以增添一些结构和功能来扩展这个 Component 。 Props在上一个例子中，可以看到有一个特殊的引用： this.props.name。 这个引用称之为 Props，可以将他想象成 Component 的设置选项。 在使用上， Props 类似于 HTML 中的属性： 1React.render(&lt;HelloMessage name="foo" /&gt;, document.body); 在 Component 内部，通过 this.props.name 来引用这个 Props： 12345var HelloMessage = React.createClass(&#123; render: function () &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;); 需要注意的是， Props 仅用来定制 Component， 这些数据不应该被改动。 如果涉及到需要做改动的数据， 得考虑使用 state。 Stateful ComponentState 数据代表 Component 的状态， 用于维护 Component 内部的状态。 当 State 发生改变之后， React 将会重新渲染 UI 。调用 与 Props 类似， State 数据通过 this.state 访问： 1234567891011121314151617181920212223var Greeting = React.createClass(&#123; getInitialState: function () &#123; return &#123; greeted: false &#125;; &#125;, greet: function () &#123; this.setState(&#123; greeted: true &#125;); &#125;, render: function () &#123; var response = this.state.greeted ? 'Hi' : ''; return ( &lt;div&gt; &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt; &lt;span&gt;&#123;response&#125;&lt;/span&gt; &lt;button onClick=&#123;this.greet&#125;&gt;Hi&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;);React.render(&lt;Greeting name="foo" /&gt;, document.body); 这个例子中加了几个函数，我们一一来看下。 首先是 getInitialState ， 这个方法在 Component 初始化的时候被调用， 返回 Component 初始时的状态数据。例子中，我们设置了 Component 初始时的 greeted 为 false。然后是 greet 方法，这个方法被调用之后将修改状态数据 greeted 为 true。 当 State 发生改变后， React 将 Component 渲染到 Virtual DOM，新的 Virtual DOM 与 旧版本的进行比对，检查出改变的部分并更新浏览器的 DOM。 在这个例子中，当按钮被点击后， greeted状态数据发生了变化，UI 跟随着更新。 组合结合 Props 和 State，我们就可以使用 Component 来创建完整的应用。 1234567891011121314151617181920212223242526272829303132333435var Greeting = React.createClass(&#123; getInitialState: function () &#123; return &#123; greeted: false &#125;; &#125;, greet: function () &#123; this.setState(&#123; greeted: true &#125;); &#125;, render: function () &#123; var response = this.state.greeted ? 'Hi' : ''; return ( &lt;div&gt; &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt; &lt;span&gt;&#123;response&#125;&lt;/span&gt; &lt;button onClick=&#123;this.greet&#125;&gt;Hi&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;);var users = ["foo", "bar", "baz"];var GreetingApp = React.createClass(&#123; render: function () &#123; var greetings = this.props.users.map(function (user) &#123; return &lt;Greeting name=&#123;user&#125; /&gt;; &#125;); return &lt;div&gt;&#123;greetings&#125;&lt;/div&gt;; &#125;&#125;);React.render(&lt;GreetingApp users=&#123;users&#125; /&gt;, document.body);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flipboard - 60 FPS on the mobile web]]></title>
      <url>%2F2015%2F60-fps-on-the-mobile-web%2F</url>
      <content type="text"><![CDATA[The DOM is too slow.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[适用于 WEB 开发者的 Atom 编辑器 Package]]></title>
      <url>%2F2015%2Fatom-packages-for-web-developers%2F</url>
      <content type="text"><![CDATA[这个周末试用 GitHub 的 Atom 编辑器编写一个WEB项目，感觉非常好用。 Atom 的社区很繁荣，有着丰富的扩展/插件（packages）。安装 Atom 的 Package 非常简单，可以在编辑器的偏好设置里面安装，也可以在命令行中使用 apm 命令来安装。 在介绍适用于 WEB 开发的 Package 之前，让我们快速过下如何安装 Atom Packages。 安装 Atom Package通过偏好设置安装 Package使用快捷键 command + ,/ctrl + , 打开偏好设置。点击左侧的 Install 即可浏览线上的 Package 。 顶部是一个搜索框，可以搜索已经发布在 atom.io 上的 Package ；紧接着是 Feature Packages，即精选的 Package ，列出来的是一些比较优质的 Package 。 通过 apm 命令安装 PackageAtom 自带了一个 apm 的 Package 管理工具。我们可以在命令行下执行以下命令来确认 apm 是否已经安装： 1apm help install 命令之后应该输出 apm install 的详细信息。如果输出不是 apm install 的命令信息，打开 Atom 菜单，选择 Install Shell Commands 来安装 atom 和 apm 。 确认 apm 正确安装后，便可以开始安装 Package 。正如上述执行 apm help install 所提示的，安装的命令是： 123apm install [&lt;package_name&gt;...]apm install &lt;package_name&gt;@&lt;package_version&gt;apm install --packages-file my-packages.txt Package 推荐快捷输入类 autocomplete-plus，当输入的时候，提供可能的候选项。 atom-ctags，使用 ctags 来强化自动完成功能，需借助于 autocomplete-plus。 javascript-snippets，顾名思义，输入特殊的字符后自动扩展成对应的代码片段。 vim-mode VIM-Mode 支持在 Atom 中使用 VIM 编辑器的操作方式来编辑。这对我来说是个非常 Killer 的 Package ，在此之前我一直在 WebStorm 上通过一个插件模拟 VIM 操作，异常难用。而在 Atom 上的这个模拟VIM操作，使用起来感觉还是比较顺手的。你可以混合 VIM 操作和普通的编辑操作。 emmet 手写 HTML 多少显得专业，但是手写的问题在于得大量的代码。Emmet大幅提升手写的效率。非常值得一装。 go-to-line，跳转到指定的行，只要 ctrl + g 后输入行号即可。 Linters jshint，验证你的 JavaScript ，写更专业的 JavaScript 代码。 csslint， CSSLint 会报告出不合规定的 CSS 规则。 版本控制类 git plus，在 Atom 里面执行 Git 命令，不用来回切换终端和编辑器。 git-log，在 Atom 里面显示图形化的提交记录。 merge-conflicts，在 Atom 里面处理合并产生冲突的文件。 辅助类 minimap，为 Atom 加上 Sublime Text 的源码预览图，提供丰富的自定义选项，值得一用。 file-icons，显示文件类型对应的图标。 atom-beautify，格式化代码，更统一的代码风格。 Color Picker 在编辑器里面挑选颜色。通过右键选择 Color picker ，或者 cmd + shift + c/ctrl + alt + c 快捷键调出颜色选择面板。支持 HEX, HEXA, RGB, RGBA, HSL, HSLA 形式指定的颜色值。 csscomb，CSSComb 的一个扩展工具， CSSComb 帮你写出更漂亮的 CSS ！ autoprefixer，AutoPrefix的一个扩展工具，自动为 CSS 属性添加特定的前缀。 localization，国际化 Package ，支持简体中文。但是在我使用的版本 0.179.0 中无法使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为何使用Jekyll这样的静态编译博客？]]></title>
      <url>%2F2015%2Fwhy-to-blog-using-static-site-generator%2F</url>
      <content type="text"><![CDATA[晚上在 V2EX 看到一个讨论主题：『为什么 Jekyll 这样的静态编译博客能火?』。想到不久之前跟同事讨论过这个主题，当时作为饭后闲谈，聊过即过。今天再看到这个问题，就花了点时间把之前的一些想法写了下来。就以结论来说，我比较偏向使用静态编译博客。 （拍摄于 2015/01/18 - 厦门 福建） 如果是为了纯粹的写作，我觉得那么任何一个提供写作的平台，比如 Medium ，简书 和 新浪博客 都能让你更专注在写作上。 之前看到过一篇段子，说一警察盘问一司机为什么在后备箱装了那么多钱，然后司机想了想说，因为我能。对于使用独立博客的人来说，可能也有我能的这种心里。再加上爱折腾，所以一个新的形式出来被捧红其实不奇怪。 再说到写作方式，实际上我比较偏向静态博客的写作方式。静态博客在本地编辑文件，意味着可以选择你所喜欢的任意一个编辑器来写作，这是在线编辑办不到的，在线你只能使用一个功能有限的编辑器。 然后是存储方式，数据库存储或者文件存储我觉得这本身并不重要，重要的是数据的可管理性和安全性。选择合适的管理软件，我认为文件存储本身并没有太大的问题。静态博客有版本控制软件的助力，在数据管理和安全性上并不会比存储在数据库中差。 然后是速度，在使用静态博客的过程，因为我目前的页面仅有 200 个不到，所以构建速度在我可以接受的范围内。几条简单的命令，设置可以使用 Travis CI 来简化部署的过程，从流程上并不比后台管理麻烦。关键是这种操作过程更多显示的是一个『我能』的信息。Octpress 的宣传口号不就是『A blogging framework for hackers.』，带有很浓的装逼意味。 最后，因为 GitHub Pages 等类似网站提供了免费的托管服务，不用自己掏钱购买VPS或者虚拟主机，不用担心服务器稳定性问题。何乐而不为？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TIL - Vagrant and Unit testing]]></title>
      <url>%2F2015%2Freading-list-2015-02-03%2F</url>
      <content type="text"><![CDATA[今日阅读的文章内容主要包含两个部分，一个是Vagrant，另外一个是JavaScript的单元测试相关的知识。Vagrant的内容涉及两个方面，一篇是如何这只默认Guest机器的默认Shell；另外一篇是问题解决，当我在Guest机器中将系统升级后，出现guest additions不匹配的问题。JavaScript测试那篇文章，主要描述在编写JavaScript单元测试的时候会涉及到的框架，以及使用示例。 Switch to your favorite shell in Vagrant如果有使用Vagrant，并且想在Vagrant box里面使用zsh，这篇文章可以帮你轻松的解决这个问题。文章中举例通过Chef和Puppet来安装，以下代码是通过Chef来安装： 123456# Using Chefpackage 'zsh'execute "set zsh as default shell" do command "chsh -s $(which zsh) vagrant"end Vagrant Tip: Sync VirtualBox Guest Additions在将一个Vagrant box从Ubuntu 12.04升级到14.04后，Reload后提示： 1The guest additions on this VM do not match the install version of VirtualBox! 文章通过介绍通过安装一个Vagrant Plugin来解决这个问题，简单方便。 Testing in Browsers and Node with Mocha, Chai, Sinon, and Testem写JavaScript测试时，你可能使用到的框架以及框架的使用例子。非常实用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Code and pray]]></title>
      <url>%2F2015%2Fcode-and-pray%2F</url>
      <content type="text"><![CDATA[不久之前，发了条状态感慨说： 害怕风险不该让你成为保守派 越是严肃的产品，对于代码的质量要求越高，因为每一个bug都可能造成客户的不信任甚至客户的流失。这是一个很残酷的事实，如同在一条逆流之上，船只倒退一步，被拉开的距离可能是两步甚至更多。 为了保证质量，从确定需求到最终交付，每一个步骤都夹杂着不少人努力的汗水。而作为产品的负载体，代码的要求更是需要精细的制作。从代码被写下来的前一刻，就开始了各种测试。单元测试，开发测试，QA测试，TA测试。 bug是不可避免的，如同人无完人，但可以最大限度的避免。说来简单，实施起来如同登天。团队成员在具备过硬的技术等硬性条件的同时，还必须专注与激情。而在此条件之下，出现问题情有可原。所以说，在尽力的同时，不应害怕问题而畏首畏尾。总结问题经验，继续前进才是应有的态度，专业的态度。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读及笔记]]></title>
      <url>%2F2015%2Freading-list-2015-1-31%2F</url>
      <content type="text"><![CDATA[阅读的文章：Why I Ditched Angular for React AngularJS被人诟病最多的地方就是性能，学习曲线太陡。 DOM操作因为AngularJS严重依赖于DOM，而DOM的操作是非常昂贵的。AngularJS应用在启动后必须先遍历一边DOM，进行directive的compile，所以需要当一个页面的节点超过一定数量后，这个过程会变成一个痛点。 双向数据绑定双向数据是一把双刃剑，在ECMAScript 5中并未提供原生的数据/对象变化监视。所以，AngularJS采用了一种称为dirty checking的机制来跟踪数据的变化。当在任意一个$scope内更改了数据，Angular将触发了$digest，这个过程会导致性能问题。考虑应用绑定了一定数量的数据，一次$digest的耗时将很可观。 独立的应用循环AngularJS拥有一套自己的应用循环，这就意味着外部的更改必须通过某种方式来通知AngularJS。当与第三方库集成时，必须调用AngularJS的$apply方法，以触发$digest。 ReactJSReact将自己定位在MVC模式的V。React更鼓励适用单向的数据绑定（one-way data flow）。借助于Virtual DOM，React在性能上会显著优于AngularJS。同时作为V，React提供了一个封装component的方式，类似于AngularJS中的directive。 迁移到React?与AngularJS不同，React作为V仅专注在相应层面的实现。举例来说，AnguarJS中提供的模块化，$http/$q、Router等功能，在React中皆没有。但可以接住于其他的库来实现。 附：Quora上一个关于AngularJS和React的详细比对文章]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Karma 快速上手]]></title>
      <url>%2F2015%2Fkarma%2F</url>
      <content type="text"><![CDATA[Karma是一个JavaScript test runner。 Test Runner简单来说Test runner就是测试的实施者。很多时候，我们本身也是一个测试实施者。考虑这样一个对于前端开发者很常见的场景： 新建了一个脚本文件，并在这个脚本文件里面写上了一个函数。为了保证这个函数运行如预期，我们下一步是将脚本引用到页面上。紧接着打开浏览器，并查看执行结果。如果运行结果未如预期，我们返回编辑器，修改函数，然后再次运行测试。反复这样一个过程直至验证通过。在此过程中，我们充当的角色即是一个测试实施者。 重复的任务通常都可以自动化。Karma正是一个自动化的测试实施者。 安装KarmaKarma是一个npm模块，安装Karma异常简单。与Grunt相同，karma通常建议作为一个依赖模块安装在本地。然后通过Karma CLI运行。 12345// 安装karma依赖模块npm install karma --save-dev// 全局安装karma clinpm install -g karma-cli 安装Karma CLI之后即可在调用karma来启动测试： 1karma start 如果未安装Karma CLI，则需指定完整的本地karma路径： 1./node_modules/karma/bin/karma start 项目配置不同的项目千差万别，Karma提供了许多配置选项让项目的测试更易进行。配置文件可以通过karma init命令来生成，执行karma init之后，会进入一个交互式的命令行来配置选项。常见的配置，例如测试框架、自动捕捉的浏览器、源文件和测试文件等等。 当配置完成后，即可通过以下命令来启动测试： 1karma start karma.conf.js 一个项目可以设置多个配置文件，给karma start提供不同的文件名即可调用不同的配置： 1karma start another.conf.js PluginsKarma Plugins同样是npm模块，通过npm install来安装插件。例如，安装karma-mocha： 1npm install karma-mocha --save-dev 默认情况下，Karma为自动加载node_modules目录下与karma相邻，并以karma-开头的node模块。此类模块，例如： karma-mocha karma-coverage karma-mocha-reporter karma-phantomjs-launcher 也可以通过配置plugins属性来夹在特定的模块： 1234567891011121314// karma.conf.jsmodule.exports = function (config) &#123; config.set(&#123; // ... plugins: [ 'karma-mocha', 'karma-chai' ] // ... &#125;);&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读列表]]></title>
      <url>%2F2015%2Freading-list-2015-01-26%2F</url>
      <content type="text"><![CDATA[Smashing Magazine - An Introduction To Unit Testing In AngularJS Applications Testing tool stack: Karma - Test runner. Mocha - JavaScript test framework. Chai - Assertion Library. Sinon - Standalone test spies, stubs and mocks for JavaScript.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Out of control]]></title>
      <url>%2F2015%2Fout-of-control%2F</url>
      <content type="text"><![CDATA[（厦门的某个夜景，拍摄于 01/18/2015） 转眼又是一周过去，突然意识到的那种感慨只能一人消费，无法引起他人的共鸣。这周如同进去一个迷雾重重的森林，看不清前方的路，焦躁与恐惧轮流占领思想的高地，在迷茫中慌乱瞎转。 在一阵乱转之余，回头再看也不尽没有收获。 第一应该提到当是再听Muse，多年前最喜欢的一个乐队。Panic Station开场那旋律让我如同感觉是见到了许久未见的熟人，回到了久违的温暖之地。第一次听Muse的歌，还是在大学里的某一日下午，被一阵神秘的旋律所打动，我想Muse吸引我的绝大多数是因为歌曲中那些神秘的前奏。 第二，本周花费时间最多的网站，当属GitHub。无论上班或者下班，都会接触到GitHub。目前估计在我的网站访问量里，GitHub会超越Google成为top 1。 第三，个人主页进入下个一版本。上一个版本基于AngularJS开发，使用Yeoman构建，然后通过git subtree发布。整个堆栈看似十分壮观，但用到主页上庞大的有点吓人。按照本周同事的段子来讲就是，十分具备将一切简单事物复杂化的能力。所以在经过了三天的酝酿以后，终于在晚上找了空闲重新改版了一下。一个页面，抛弃掉原先的工具之后，感觉非常清爽。目标是在简单中体现出精细的细节，如同制作一件艺术品，久浸岁月与汗水之后沉淀而来。 第四，正在制作一个秘密的项目，期望进展顺利。 最后，小希正以日新月异的速度成长，昨晚听到电视里播放小苹果，竟然会跟着节奏晃动身体，边晃边笑。再试了下Panic Station，也会跟着晃，太逗了。现在还在吚吚哑哑，哪天就会开口要求买零食吃了，因为她是见吃必定会去抢的吃货潜力股。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读列表]]></title>
      <url>%2F2015%2Freading-list-2015-01-16%2F</url>
      <content type="text"><![CDATA[最近的项目在下一个发布将放弃对 IE8 的支持，于是准备将 AngularJS从1.2.7 升级到 1.3.x。在正式的迁移之前，对 AngularJS 1.3 的一些改动做调研，以下是今天调研的四篇文章。 Exploring Angular 1.3: One-time bindings Exploring Angular 1.3: Angular-hint Exploring Angular 1.3: ng-model-options Exploring Angular 1.3: Stateful filters 单向数据绑定双向绑定可谓 AngularJS 的核心杀手锏之一。但由于每一个绑定都增添了一个 watcher，绑定的数据在不断的增加，$digest 势必会花费更多的时间去处理。一方面许多数据只需一次性绑定即可，后续无需再次更新；另一方面，为了提高整体的性能，AngularJS 在 1.3 提供了单向的绑定。在使用上，单向数据绑定与双向仅有细微的差别，即在 {{}} directive 中，为绑定的数据添加 :: 前缀即可: 12Hello, &#123;&#123; name &#125;&#125; // 双向绑定Hello, &#123;&#123; ::name &#125;&#125; // 单向绑定 angular-hint AngularJS 1.3 中新增一个 angular-hint 模块，这个模块旨在帮助开发者更易于开发 AngularJS 应用程序，避免开发中一些易遗漏，但难于调试的问题。例如，在 HTML 中引入了一个新的 directive ，但是忘记将这个 directive 加入 application 的依赖模块中。使用这个模块的步骤如下： 下载 angular-hint 模块 1npm install --save angular-hint 在页面中引用此模块 1&lt;script src="path/to/angular-hint/hint.js&gt;&lt;/script&gt; 使用 ng-hint directive 1&lt;html ng-app="exampleApp" ng-hint&gt; 新增的 angular-hint 包含 5 个子模块：angular-hint-controllers, angular-hint-directives, angular-hint-dom, angular-hint-events, angular-hint-modules 以及 angular-hint-interpolation，各个模块对应不同的错误类型检测。使用 angular-hint 的时候，可以仅使用其中的某个/些模块： 1&lt;html ng-app="exampleApp" ng-hint-include="dom directives"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The ButterFly Effect]]></title>
      <url>%2F2015%2Fthe-butterfly-effect%2F</url>
      <content type="text"><![CDATA[人的一切痛苦，本质上都是对自己的无能的愤怒。王小波 一只上海的蝴蝶煽动翅膀后，引起了厦门两个人的龙卷风。世事无常，往往事情的发展总出人意料，令人啼笑皆非。且不问结果如何，尽自己之所能，积极地面对。古语有言，尽人事听天命，大概便是如此。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Link directives after asynchronous calls in AngularJS]]></title>
      <url>%2F2015%2Flink-directives-after-asynchronous-calls-in-angularjs%2F</url>
      <content type="text"><![CDATA[在许多场景中，需要等待异步的请求完成后对DOM进行操作。例如，在异步获取图片数据后，对图片进行等比缩放。对于DOM的操作通常放置在directive中，而当数据是异步请求的时候，DOM的数据并未就绪，此时在directive中去操作时会无法找到数据进而导致操作失败。 考虑对图片进行等比缩放的场景，假定将图片缩放的操作放置在image-resize的directive中，图片的src等待异步请求后才能获取到。HTML代码如下： 1&lt;img ng-src="image.src" alt="image.alt" image-resize /&gt; ng-src绑定到image.src上，在此数据变化时就可以判定获取图片地址的异步请求已经完成。所以，在image-resize中通过监视ng-src这个属性，当变化的时候就进行缩放操作： 1234567891011angular.module('directives', []) .directive('imageResize', [function () &#123; return &#123; restrict: 'A', link: function ($scope, $element, $attrs) &#123; $attrs.$observe('ngSrc', function () &#123; // Resize image. &#125;); &#125; &#125;; &#125;]); 由于对于图片的操作仅需在获取到图片地址后执行一次，所以使用$attributes.$observe并不是一个上等的方案。如果能在异步执行完成，执行directive就无需进行监视操作。在AngularJS中，directive首先会被compile一次，并在第一次使用的时候进行link，而第一使用受类似ng-if等的限定。 也就是说，当一个DOM元素上的ng-if中表达式为false时，元素上的其他directive不会被link。使用这个特性，以上的代码可以简写： 12&lt;!-- 新增了ng-if，绑定到image.loaded变量上--&gt;&lt;img ng-src="image.src" alt="image.alt" ng-if="image.loaded" image-resize /&gt; 同时image-resize内部对于ngSrc属性的监视也可以去掉： 12345678910angular.module('directives', []) .directive('imageResize', [function () &#123; return &#123; restrict: 'A', link: function ($scope, $element, $attrs) &#123; // 无需监视attr.ngSrc属性 // Resize image. &#125; &#125;; &#125;]); 当异步请求完成时，将image.loaded变量设定为true，当AngularJS执行下一轮digest的时候，图片元素上的ng-if结果为true，触发resize-image的link，此后即可以对图片进行后续的操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读]]></title>
      <url>%2F2015%2Freading-list-2015-01-04%2F</url>
      <content type="text"><![CDATA[JavaScript Application Architecture On The Road To 2015 Vagrant - GETTING STARTED Vagrant - PROJECT SETUP Vagrant - BOXES Vagrant - UP AND SSH Vagrant - SYNCED FOLDERS Create a CSS Flipping Animation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactJS: Keep Simple. Everything can be a component!]]></title>
      <url>%2F2014%2Freactjs-keep-simple-everything-can-be-a-component%2F</url>
      <content type="text"><![CDATA[Talk about ReactJS and how to turn your development process to much easier and simple. By Pedro Nauck]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Using custom fonts in Rails 4]]></title>
      <url>%2F2014%2Fusing-custom-fonts-in-rails-4%2F</url>
      <content type="text"><![CDATA[在 Rails 4 应用中使用自定义字体，只需以下步骤： 在 app/assets 目录下添加fonts目录 将自定义字体放置于 app/assets/fonts 目录下 在定义字体的 CSS 文件中，使用 font-url 函数来调用字体。例如： 123456@font-face &#123; font-family: 'Lato', src: font-url('lato.woff') format('woff'); font-weight: normal; font-style: normal;&#125; 另外，当使用多种自定义字体的时候，可以将字体文件放进各自的子目录中。引用的时候，只要在对应的字体定义中包含子目录名称即可。例如： 123@font-face&#123; src: font-url('lato/lato.woff') format('woff');&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读]]></title>
      <url>%2F2014%2Freading-list-2014-12-29%2F</url>
      <content type="text"><![CDATA[How to prevent page scrolling when scrolling a DIV element? Element.scrollIntoView() getBoundingClientRect is Awesome]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读]]></title>
      <url>%2F2014%2Freading-list-2014-12-28%2F</url>
      <content type="text"><![CDATA[RailsGuide - Rails 入门RailsGuide - Action Controller 简介RailsGuide - Rails 路由全解RailsGuide - Rails 布局和视图渲染RailsGuide - Active Record 基础RailsGuide - Active Record 关联]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Debug grunt tasks with node-inspector]]></title>
      <url>%2F2014%2Fdebug-grunt-tasks-with-node-inspector%2F</url>
      <content type="text"><![CDATA[随着项目的增长，Grunt任务也相对地变复杂。通过console.log或者grunt.log.writeln等方法去调试会变得越来越耗时。所幸的是，可以使用Node Inspector来做断点调试，以增加Grunt任务的开发效率。 Node Inspector是一个基于Blink Developer Tools的图形化调试工具，可以用来调试NodeJs应用。安装Node Inspector： 1npm install -g node-inspector 完成之后即可以开始调试，步骤如下： 在任务代码中添加断点代码debugger 启动Node Inspector node-debug --web-port=9999 grunt-path task-name --task-option 在Windows 7系统中, 如果通过全局安装grunt-cli的话，那么grunt-path 就是 %appdata%\npm\node_modules\grunt-cli\bin\grunt。 参考： Node Inspector Using node-inspector with grunt tasks]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Test if links are external with JavaScript]]></title>
      <url>%2F2014%2Ftest-if-links-are-external-with-javascript%2F</url>
      <content type="text"><![CDATA[12345678910var internalLinkPattern = new RegExp(location.host);var links = document.querySelectorAll('a');for (var i = 0; i &lt; links.length; i++) &#123; var link = links[i]; internalLinkPattern.test(link.href) ? link.setAttribute('data-target', 'internal') : link.setAttribute('data-target', 'external');&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery selector with dot character]]></title>
      <url>%2F2014%2Fjquery-selector-with-dot-character%2F</url>
      <content type="text"><![CDATA[在最近的一个项目中，使用grunt作为脚本工具，将一组HTML文件合并成一个文件，并使用各个文件的名称作为合并后片段的id值。也就是说，在合并后的文件中，将会存在类似如下的HTML代码： 12345&lt;div class="content"&gt; &lt;div class="section" id="chapter1.html"&gt;...&lt;/div&gt; &lt;div class="section" id="chapter2.html"&gt;...&lt;/div&gt; &lt;div class="section" id="chapter3.html"&gt;...&lt;/div&gt;&lt;/div&gt; 每个section的id值是以chapterX.html的形式存在。当使用jQuery去选择这些元素的时候，要做一定的处理。默认情况下，选择器#chapter1.html将会匹配class中包含.html，并且id值是chapter1的元素。从HTML角度来看就是： 1&lt;div class="html" id="chapter"&gt;...&lt;/div&gt; 那么要匹配id=&quot;chapter1.html&quot;指定的元素，就需要对.字符进行转换。这种字符在jQuery中称为元字符，包括有： 1!"#$%&amp;'()*+,./:;&lt;=&gt;?@[\]^`&#123;|&#125;~ 转义是使用两个反斜杠，比如对于.元字符要写成\\.。所以对于例子中的选择器需要改写成： 1var sections = $('#chapter\\.html'); 参考： Selectors]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Say goodbye to the crazy week]]></title>
      <url>%2F2014%2Fsay-goodbye-to-the-crazy-week%2F</url>
      <content type="text"><![CDATA[一曲《爱你在心口难开》开启了疯狂加班周的最后一天。天空灰蒙蒙，地面一片潮湿，一扫昨天的风和日丽。所幸的是，气温保持在10摄氏度以上，加上歌曲轻快的旋律，心情多少不至于太多低落。 自从购买了惠威MK200III，忽然发觉就单歌曲兴趣方面，我正在快速的老去。记得在哪里有看过一句话说，当人开始怀念时，说明他们已经老去。我意识到我的症状比这个更为严重，新歌已经完全绝缘，老歌越听越上瘾。 在知乎上有这样一个问答： 问：大叔在KTV里唱红歌是什么原因？答：你听到的是红歌，他唱的岁月。 深深赞同。喜欢上一首歌曲可能仅仅因为歌曲与当时的心境相符，被代入感所左右。经过岁月的蹉跎，情感渐渐地迟钝，于是慢慢地那种代入感消失，新歌已然无法触及心灵。取而代之的是过去岁月的回忆，开始影响感官。 即时在资源再匮乏的时代，人们依然可以找到乐趣，然后深深地烙印在心里，等待再翻起。不知不觉的，我已经到了开始翻起这些记忆的年龄。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Waiting for DOM to finish rendering in AngularJS]]></title>
      <url>%2F2014%2Fwaiting-for-dom-to-finish-rendering%2F</url>
      <content type="text"><![CDATA[在AngularJS中directive的link阶段，如果去操作DOM时可能会获取到错误的数据。比如，编写相对视窗固定的组件时，在link阶段可能无法获取到元素的正确初始偏移位置。在这种情形中，只要借助与$timeout，将操作DOM的相关数据加入event loop，等待DOM的渲染完成后即可做后续的操作。 123$timeout(function handler() &#123; // Handle DOM.&#125;, 0); $timeout函数返回一个Promise对象，意味着可以在handler处理完成后执行一些操作。例如，使用一个flag来标记是否第一个操作： 12345678var did = false;var handlePromise = $timeout(function handler() &#123;&#125;);handlePromise.then(function () &#123; did = true;&#125;);// 使用did标记的后续处理 参考： Run a directive after the DOM has finished rendering]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Morning]]></title>
      <url>%2F2014%2Fmorning%2F</url>
      <content type="text"><![CDATA[十二月中旬的厦门，终于有点寒意。天空蔚蓝，阳光明媚，街边的树叶在阳光的照射下随清风轻轻摇曳，如同绿色的波浪，起而又落。这是一个平凡干净的清晨。 路上车辆行人来往匆匆，在这个城市穿梭，为朴实无华的生计奔波劳累，为渺小伟大的梦想奋斗不已。清新的早晨夹带一丝忙碌，透着隐约的浮躁。 忽然想起电影《素媛》，以明朗的日子开头，剧情忽然急转直下。故事异常承重，很多时候，除了接受，我们只剩无奈，作为一个旁边者，当明白了这个结果，心里始终无法去承受。一个意外的事件的发生，给一个普通的家庭造成了巨大的影响，给一个普通的人造成了无法弥补的伤害。现实生活即使如此，当我们每一天睁开眼睛，对于接下来会发生的任何的事情都没有预期，任时间无情的将我们推向未知的不连续的一个个事件中。 最残酷的事，当无奈之后，日子依然如旧。这部电影让我感触最深的一幕是在素媛康复后的日子，生活又走上原来的轨道，素媛的父亲躺着沙发在依然对着电视里的球赛吼叫。所有的痛苦、后悔、愤恨，如同沙漠之地，被风一层层的盖在心底的深处。 当风偶尔翻起那一片饱含泪水的沙子时，各种情感如同黑暗将我们吞噬，于是坠入无尽的深渊。在深渊中挣扎，在黑暗中放任，当风再次来过，日子依然如旧。除了无奈，只有感叹。 早安，厦门。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读列表]]></title>
      <url>%2F2014%2Freading-list-2014-12-16%2F</url>
      <content type="text"><![CDATA[‘Resolve’ in AngularJS Routes, Explained as Story AngularJS - Watch for changes in a service. Share state between controllers in AngularJS A Tale of Frankenstein and Binding to Service Values in Angular.js Consuming Services]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Change Yosemite default font]]></title>
      <url>%2F2014%2Fchange-yosemite-default-font%2F</url>
      <content type="text"><![CDATA[Replace Helvetica Neue on your 10.10 Yosemite Mac with: San Francisco Lucida Grande]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Disqus articles]]></title>
      <url>%2F2014%2Fdisqus-articles%2F</url>
      <content type="text"><![CDATA[In a recent project, I am working on a requirement that integrate DISQUS comment system into an AngularJS Blog app.The following list is the references that I have researhced. How does Disqus work? JavaScript configuration variables Using Disqus on AJAX sites What is a Disqus identifier? Why are the same comments showing up on multiple pages? Adding comment count links to your home page Testing the API (Using the Console) DISQUS comment count code uncompressed DISQUS-API-Recipes angular-disqus]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Transclusion and Scopes]]></title>
      <url>%2F2014%2Ftransclusion-and-scopes%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[いつも何度でも]]></title>
      <url>%2F2014%2Falways-with-me%2F</url>
      <content type="text"><![CDATA[呼んでいる 胸のどこか奥で いつも心踊る 梦を见たい 内心深处的呼唤 我想要走进悸动的梦中 悲しみは 数えきれないけれど その向こうできっと あなたに会える 虽然悲伤会重演 但我一定能在某处与你相逢 缲り返すあやまちの そのたびひとは ただ青い空の 青さを知る 人们总是不停犯错 他们只知道天是蓝的 果てしなく 道は続いて见えるけれど この両手は 光を抱ける 虽然前路渺茫 但他们的双手仍在寻找光明 さよならのときの 静かな胸 ゼロになるからだが 耳をすませる 离别时平静的心，身体归于虚无时的倾听 生きている不思议 死んでいく不思议 花も风も街も みんなおなじ 莫名的生存，莫名的死去 花，风，城市都是如此 ラララ… ホホホ… フフフ… 呼んでいる 胸のどこか奥で いつも何度でも 梦を描こう 内心深处的呼唤 让我们不停的画出梦的色彩 悲しみの数を 言い尽くすより 同じくちびるで そっとうたおう 比起回忆的心中的悲伤 不如用同样的唇轻声歌唱 闭じていく思い出の そのなかにいつも 忘れたくない ささやきを闻く 即使在封锁的回忆中 仍然还有无法忘记的呢喃 こなごなに砕かれた 镜の上にも 新しい景色が 映される 即使在粉碎的镜片中 仍然能映出新的景色 はじまりの朝 静かな窓 ゼロになるからだ 充たされてゆけ 晨色初照下的宁静窗台 还有那化为虚无的身体 海の彼方には もう探さない 辉くものは いつもここに 从此我不会越过大洋去寻找 闪耀的所有都在身边 わたしのなかに 见つけられたから 我将自己去追寻 ラララ… ホホホ… フフフ…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[How to Manage Multi-Line Ellipsis in Pure CSS]]></title>
      <url>%2F2014%2FCSS-Ellipsis-How-to-Manage-Multi-Line-Ellipsis-in-Pure-CSS%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Two years with Angular]]></title>
      <url>%2F2014%2Ftwo-years-with-angular%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[世界末日在昨天，今天有更严重的问题]]></title>
      <url>%2F2014%2Fthe-end-of-the-world-is-yesterday%2F</url>
      <content type="text"><![CDATA[世界末日在昨天，今天有更严重的问题 《龙文身的女孩》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A Guide to Branching in Mercurial]]></title>
      <url>%2F2014%2Fa-guide-to-branching-in-mercurial%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA['Thinking in AngularJS' if I have a jQuery background?]]></title>
      <url>%2F2014%2Freading-list-2014-11-18%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读列表]]></title>
      <url>%2F2014%2Freading-list-2014-11-17%2F</url>
      <content type="text"><![CDATA[CSS Custom Properties for Cascading Variables Module Level 1 Myth - A preprocessor lets you write pure CSS Broswerrify How to structure a Sass project A Little Structure For Your Large Sass Project]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The Rust Guide]]></title>
      <url>%2F2014%2Freading-list-2014-11-16%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读列表]]></title>
      <url>%2F2014%2Freading-list-2014-11-14%2F</url>
      <content type="text"><![CDATA[GitHub’s CSS - @mdo Animating Link Underlines A Pocket Guide to Master Every Day’s Typographic Adventures LESS: Getting Started]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS Trick: Sticky Footer]]></title>
      <url>%2F2014%2Fsticky-footer%2F</url>
      <content type="text"><![CDATA[A sticky footer means the footer is always sticky to bottom and comes after the content. 固定的页脚是指页脚紧跟在内容区域后面，并且一直处于页面的底部。 That is to say, the position of Footer is independent with content’s height, it always sticky to the bottom of the page: 也就是说，无论内容的多少都不影响到Footer的位置，Footer总是出现在页面的最底部： When height of content is greater than viewport’s height, Footer follows the content, so it won’t appear on the first screen. 当页面的内容的高度大于Viewport的高度时，Footer的位置在内容之后，首屏是无法看见的； When hegiht of content is less than viewport’s height, Footer still appear on the bottom of page. 当页面的内容的高度少于Viewport的高度时，Footer依然保持在Viewport的底部； Obviously, position: fixed does not suite for this case. Elements with position: fixed use viewport as the reference, so these elements will always appear at the bottom of viewport whatever the content’s height is. This does not meet the first requirment. 显然，position: fixed并不适用于当前的场景，因为fixed定位的元素是以viewport作为参照物，所以在fixed的情况下，无论内容多于少，这些元素总是出现在浏览器窗口的底部，这并不满足需求的第一个要求。 Rule position has two value to take elements out of normal flow, the first we just talk about, is fixed, the other one is absolute. Elements’s position with absolute is relative to thier parent whose position value is not static. So we can use this feature to design a container, it meets the following conditions: 元素脱离文档流的定位除了fixed以外，还有一个是absolute。使用absolute定位的元素是以最近一个position属性不是static的父元素作为参照物。此时，就可以设计一个Footer的参照容器，这个容器满足以下条件： It should Wrap the content and Footer.包含内容和Footer. It’s minimum height should be 100 percent of viewport.容器高度至少是viewport的100%. For this container, it will be automaticlly expand when the content’s height is bigger than viewport’s; while the content’s height is less than viewport’s, the container still as tall as viewport so that Footer will locate at the bottom of the viewport. 满足以上条件的容器，在页面内容高度大于viewport的高度时，容器自动被撑开；当页面内容的高度小于viewport的高度时，自动取viewport的高度，从而保证Footer还是在页面的底部。 Enough theory, let’s take a look at the code. 讨论完足够的理论之后，让我们来看看代码。 HTML 1234567&lt;div class="container"&gt; &lt;div class="header"&gt;&lt;/div&gt; &lt;div class="content-wrap"&gt; &lt;div class="content"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt;&lt;/div&gt;&lt;/div&gt; CSS 123456789101112131415161718192021html, body &#123; /* For container-wrap to inherit */ height: 100%;&#125;.container-wrap &#123; position: relative; min-height: 100%; /* &#125;.content &#123; /* The space for footer */ padding-bottom: $footerHeight;&#125;.footer &#123; position: absolute; bottom: 0; left: 0; height: footerHeight;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[今日阅读列表]]></title>
      <url>%2F2014%2Freading-list-2014-11-13%2F</url>
      <content type="text"><![CDATA[All About Angular 2.0 Front-end Tooling Workflows - Addy Osmani]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac平台下在命令行打开SublimeText]]></title>
      <url>%2F2014%2Fopen-sublimetext-from-terminal-on-mac%2F</url>
      <content type="text"><![CDATA[Mac下通过别名在命令行中打开SublimeText: 1alias sublime='open -a "Sublime Text"' 应用场景： 12$ git clone repo-address repo$ cd repo &amp;&amp; sublime .]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TDD短迭代]]></title>
      <url>%2F2014%2FTDD-iteration%2F</url>
      <content type="text"><![CDATA[编写一个测试（明确将要做什么） 运行测试，观察测试失败（确认测试代码以及测试用例） 使测试通过（放手去做，不要害怕硬编码） 重构（消除冗余，寻找更优方案）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Medium's CSS is actually pretty f***ing good]]></title>
      <url>%2F2014%2Freading-list-2014-09-28%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[ngBook - Scopes]]></title>
      <url>%2F2014%2Fngbook-scopes%2F</url>
      <content type="text"><![CDATA[Scopes are a core fundamental of any Angular app. They are used all over the framework, so it’simportant to know them and how they work.The scopes of the application refer to the application model. Scopes are the execution context for expressions. The $scope object is where we define the business functinality of the application, the methods in our controllers, and properties in the views. Scopes serve as the glue between the controller and the view. Just before our app renders the view to the user, the view template links to the scope, and the app sets up the DOM to notify Angularfor property changes. This feature makes it easy to account for promises, such as an XHR call, to be fulfilled. See the promises chapter for more details. Scopes are the source of truth for the application state. Because of this live binding, we can relyon the $scope to update immediately when the view modifies it, and we can rely on the view to update when the $scope changes. $scopes in AngularJS are arranged in a hierarchical structure that mimics the DOM and thus arenestable: We can reference properties on parent $scopes. If you are familiar with JavaScript, then this hierarchical concept shouldn’t be foreign. When we create a new execution context in JavaScript, we create a new function that effectively creates a new ‘local’ context. The Angular concept of $scopes is similar in that as we create a new scope for child DOM elements,we are creating a new execution context for the DOM to live in. Scopes provide the ability to watch for model changes. They give the developer the ability to propagate model changes throughout the application by using the apply mechanism available on the scope. We define and execute expressions in the context of a scope; it is also from here that we can propagate events to other controllers and parts of the application.It is ideal to contain the application logic in a controller and the working data on the scope of the controller. From: ngBook - scopes]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kaizen]]></title>
      <url>%2F2014%2Fkaizen%2F</url>
      <content type="text"><![CDATA[一位参观英格兰伊顿公学的游客问那里的园丁，他是怎样让草坪变得如此完美的。“那很容易，”园丁回答说，“你只要每天早晨拂去卤水，每隔一天割一次草，每个星期碾压以此就行了。” “就是这些吗？”游客问。 “就是这些，”园丁回答说，“这样做上500年，你也将拥有一片漂亮的草坪。” 了不起的草坪需要每一天给予一点关心，了不起的程序员也是这样。管理顾问们喜欢在谈话中扔出“Kaizen”这个词，“Kaizen”是一个日本术语，表达的是持续的做出许多小改进的概念。它被认为是日本制造业在生产率与质量方面取得长足进步的主要原因之一，并且在世界各地得到了广泛的效仿。Kaizen也适用于个人。每天为提炼你所拥有的技能而工作，为把新的工具增加到你的技能列表中而工作。与伊顿的草坪不同，你在几天之中就将开始看到结果。几年之后，你将会惊奇你的经验得到了怎样的发展，你的技能得到怎样的提升。 《程序员修炼之道》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Deciding what not to do is as important as deciding what to do.]]></title>
      <url>%2F2014%2Fwhat-not-to-do-and-what-to-do%2F</url>
      <content type="text"><![CDATA[Deciding what not to do is as important as deciding what to do. Steve Jobs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Function bind polyfill]]></title>
      <url>%2F2014%2Ffunction-bind-polyfill%2F</url>
      <content type="text"><![CDATA[A polyfill function for ES5 Function.prototype.bind: 123456789101112131415161718192021if (!Function.prototype.bind) &#123; Function.prototype.bind = function (obj) &#123; var slice = [].slice; var args = slice.call(arguments, 1); var self = this; var nop = function () &#123;&#125;; var bound = function () &#123; return self.apply( this.instanceof nop ? this : (obj || &#123;&#125;), args.concat(slice.call(arguments)) ); nop.prototype = self.prototype; bound.prototype = new nop(); return bound; &#125;;&#125;// fn.bind(obj&#125;) =&gt; obj.bound =&gt; obj.bound(args)// Ctrl.bind(new Ctrl())]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Express - app.router]]></title>
      <url>%2F2014%2Fapprouter-in-expressjs%2F</url>
      <content type="text"><![CDATA[In ExpressJS 3.x, you may see a line code: 1app.use(app.router); Briefly, app.router is the component that knows what to do when you call app.get() etc. See the Connect documentation for the router middleware to understand what it does. Why is order important?If the router middleware was installed before the session middleware, your router handlers would run before the sesssion middleware so the session wouldn’t be setup until after your handler completed; if the route middleware was installed after the errorHandler middleware, errorHandler wouldn’t get a chance to deal with error from your route handler because it would have been run before the router handler got called. Bacically, you need to install app.router explicitly if you have other middleware that you need to ensure come after it in the stack. References: How does app.router work?(SO) app.use(app.router) question (Google Groups)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Split in javascript]]></title>
      <url>%2F2014%2Fsplit-in-javascript%2F</url>
      <content type="text"><![CDATA[In JavaScript, split behaves a litte different than expected. For example, we have a string needed to be split into pieces: 12var str = 'Steve Jobs, Deciding what not to do is, ' + 'as important as deciding what to do'; Say, we need to split and format the above string into: 1Steve Jobs: Deciding what not to do is, as important as deciding what to do. If we use split without limitation: 12var pieces = str.split(',');console.log(pieces); Actually, we got: 1[Steve Jobs, Deciding what not to do is, as important as deciding what to do]`. So we add another argument: 12var pieces = str.split(',', 1);console.log(pieces); Got Only [Steve Jobs]. The result is not we except. The second argument just identify how many elments in the spilt pieces would return. So we need to do the split ourself: 123456789101112131415161718function splitEnhanced(str, seperator, maxSplit) &#123; var pieces = str.split(seperator); var result = []; if (!maxSplit) &#123; return pieces; &#125; while (maxSplit &gt; 0) &#123; result.push(pieces.shift()); maxSplit--; &#125; result.push(pieces.join(seperator)); return result;&#125;var pieces = splitEnhanced(str, ',', 1);console.log(pieces.join(':'));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJs Unit Testing]]></title>
      <url>%2F2014%2Fangularjs-unit-testing%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[A comprehensive guide to styling file inputs]]></title>
      <url>%2F2014%2Fa-comprehensive-guide-to-styling-file-inputs%2F</url>
      <content type="text"><![CDATA[Full video game engine with 3D rendering and real-world physics in a browser? Yes. Ability to style &lt;select&gt; dropdowns in a browser? No. Nicholas C. Zakas - @slicknet]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Action methods vs Normal methods]]></title>
      <url>%2F2014%2Faction-methods-vs-normal-methods%2F</url>
      <content type="text"><![CDATA[So what is the difference between an action method and a regular method? Nothing. An action method is really just the same as any other method. The only special thing is the (IBAction) specifier. This allows Interface Builder to see the method so you can hook it up to your buttons, sliders, and so on. Other methods, such as viewDidLoad, do not have the IBAction specifier. This is a good thing because all kinds of mayhem would occur if you hooked them up to your buttons. This is the simple form of an action method: 1- (IBAction)doSomething; You can also ask for a reference to the object that triggered this action: 1- (IBAction)buttonTapped:(UIButton *)button; But this method cannot be used as an action from Interface Builder: 1- (void)someOtherMethod;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Properties v.s Instance Variables]]></title>
      <url>%2F2014%2Fproperties-vs-instance-variables%2F</url>
      <content type="text"><![CDATA[Properties and instance variables have a lot in common. In fact, when you create a property, it is “backed” by an instance variable. That means your slider property stores its value in an instance variable named _slider (note the leading underscore). This instance variable was automatically added to the view controller by the Objective-C compiler. Why? Well, a property needs to store its value somewhere and an instance variable is a good place for that. You can tell the difference between the two because properties are always accessed using self.This uses the property: 1self.slider.value = 50; This uses the backing instance variable directly: 1_slider.value = 50; So what is the added benefit of using a property over an instance variable? There are several reasons but mainly instance variables are supposed to be used only by the insides of an object. Other objects aren’t intended to see them or use them. Properties, however, can be accessed by other objects that are outside of your view controller. You’ll learn much more about this in the next tutorials because “information hiding” is an important topic in object-oriented programming. By the way, properties are not just for making outlets. It is customary to use properties for the outlets in your storyboard, but as you will see later, you can also make properties for things that are not in the storyboard.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Express - Setting view engine]]></title>
      <url>%2F2014%2Fexpress-settings-view-engine%2F</url>
      <content type="text"><![CDATA[view engine holds the template file extension, e.g. ‘jade’ or ‘html’. Omitting this variable will cause res.render failed to load templates. Explicitly specify the extension if omitted this variable: 1res.rend('index.jade', datas);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Express - Setting environment]]></title>
      <url>%2F2014%2Fexpress-settings-env%2F</url>
      <content type="text"><![CDATA[env variable is used to store the current environment node for this particular Node.js process. The value is automatically set by Express.js from process.env.NODE_ENV, or development if that value is not set. The most common values for env setting are: test stage preview production We can argument the env by: 1234app.set('env', 'preview');// ORprocess.env.NODE_ENV = 'preview'; However, the better way is to start the app in the CLI: 1NODE_ENV=preview node app]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Watchers for express application development]]></title>
      <url>%2F2014%2Fwatchers-for-express-application-development%2F</url>
      <content type="text"><![CDATA[There are brilliant tools that can leverage watch method from the core Node.js fs module and restart server when changes are made: Supervisor up node-dev nodemon]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bootstrap an express application]]></title>
      <url>%2F2014%2Fbootstrap-express-app%2F</url>
      <content type="text"><![CDATA[Things we perform in a express application’s entry point file: Import dependencies. Configurations. Such as the template engine. Define Middlewares. Define Routes. Connection to DB. Start the app. Example: 123456789101112131415161718192021222324252627// Dependencies.var expres = require('express');var app = express();// Configurations.var port = process.env.PORT || 7654;app.set('port', port);app.set('view', __dirname + '/views');// Middlewares.app.use(express.favicon());app.use(express.static(__dirname + '/public'));app.use(express.bodyParser());app.use(express.methodOverride());app.use(express.session());// Routes.app.get('*', function (req, res) &#123; res.end('Hello World!');&#125;);// DB Connection.// Start.app.listen(port, function () &#123; console.log('Service is running on: ', port);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Explanation of angular module]]></title>
      <url>%2F2014%2Fexplanation-of-angular-module%2F</url>
      <content type="text"><![CDATA[From AngularJS Fundamentals in 60-ish Minutes]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shadow DOM 101]]></title>
      <url>%2F2014%2Fshadow-dom-101%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub - Display images in the README]]></title>
      <url>%2F2014%2Fgithub-display-images%2F</url>
      <content type="text"><![CDATA[There are two ways to make GitHub rendering images in the README: Using relative path. Append ?raw=true to the image uri: 1![](path/to/image.png?raw=true) Use the intact uri of the image in the GitHub repository: 1![](https://github.com/username/reponame/blob/master/images/image.png)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The challenge with SPA]]></title>
      <url>%2F2014%2Fthe-challenge-with-spa%2F</url>
      <content type="text"><![CDATA[There are many challenges with SPAs, including: Routing Object Modeling Module Loading View Loading Data Binding Ajax/Promises History Caching From AngularJS Fundamentals in 60-ish Minutes]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DockerCon 2014 Solomon Hykes]]></title>
      <url>%2F2014%2Fdockercon-2014-solomon-hykes%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub flow]]></title>
      <url>%2F2014%2Fgithub-flow%2F</url>
      <content type="text"><![CDATA[GitHub Flow is a lightweight, branch-based work flow that supports teams and projects where deployments are made regularly.This guide explains how and why GitHub Flow works.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git Setup a tracking branch]]></title>
      <url>%2F2014%2Fgit-setup-a-tracking-branch%2F</url>
      <content type="text"><![CDATA[1234567891011121314# Setup upstream repositorygit remote add upstream path-to-upstream# Fetch upstream's branchesgit fetch upstream# List all branchesgit list --all# Setup a tracking branchgit checkout -b foo --track upstream/foo# Or omit the `-b` argumentgit checkout --track upstream/foo Related Question: How to clone all remote branches with Git?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Using SVG]]></title>
      <url>%2F2014%2Fusing-svg%2F</url>
      <content type="text"><![CDATA[SVG is an image format for vector graphics. It literally means Scalable Vector Graphics. Basically, what you work with in Adobe Illustrator. You can use SVG on the web pretty easily, but there is plenty you should know. Article on CSS-Tricks.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The refactoring tales]]></title>
      <url>%2F2014%2Fthe-refactoring-tales%2F</url>
      <content type="text"><![CDATA[Welcome to The Refactoring Tales, a book that documents some of the refactorings and changes I’ve made in recent (and mostly real-life) projects. This book isn’t going to teach you about language constructs, conditionals, functions, or so on, but hopefully offer insight into how to take steps to make your code more readable and more importantly, maintainable. Jack Franklin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Examples of using apply function]]></title>
      <url>%2F2014%2Fsome-examples-of-using-apply-function%2F</url>
      <content type="text"><![CDATA[Example 1: Append an array to another array. 12345var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];Array.prototype.push.apply(arr1, arr2);console.log(arr1); // [1, 2, 3, 4, 5, 6] Example 2: Get the max/min item in an array of numbers. 123var numbers = [12, 1, 35, 98, 34, 100];var max = Math.max.apply(Math, numbers);var min = Math.min.apply(Math, numbers);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Grunt import external data]]></title>
      <url>%2F2014%2Fgrunt-import-external-data%2F</url>
      <content type="text"><![CDATA[Grunt has two methods for importing external data: grunt.file.readJSON grunt.file.readYAML For example, you can load data from a file into configuration of GruntFile: 123456789101112module.exports = function (grunt) &#123; grunt.config.init(&#123; colors: grunt.file.readJSON('colors.json'), white: '&lt;%= colors.white %&gt;', green; '&lt;%= colors.green %&gt;' &#125;); grunt.registerTask('default', function () &#123; grunt.log.writeln(grunt.config.get('green')); &#125;);&#125;); Using Tempalte to store external data into specific config properties, such as white and green in the above example. Then, you can get the data by method grunt.config.get().]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git pull with rebase and why]]></title>
      <url>%2F2014%2Fgit-pull-with-rebase%2F</url>
      <content type="text"><![CDATA[Users of Git are hopefully aware that a git pull does a git fetch to pull down data from the specified remote, and then calls git merge to join the changes received with your current branch’s work. However, that may not always be the best case. You can also rebase the changes in, and that may end up being a lot cleaner. This can be done simply by tacking on the --rebase option when you pull, like so: 1git pull --rebase &lt;remote name&gt; &lt;branch name&gt; Read More on Git Ready Related Question: Difference between git pull and git pull –rebase]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[List available grunt tasks of a project]]></title>
      <url>%2F2014%2Flist-available-grunt-tasks%2F</url>
      <content type="text"><![CDATA[In the project’s directory, run: 1grunt --help]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Install Node.js from source on CentOS]]></title>
      <url>%2F2014%2Finstall-nodejs-from-source-on-centos%2F</url>
      <content type="text"><![CDATA[Before we start, it would be a good idea to update software repository tothe latest version:1yum -y update Steps:Install Development Tools. Development Tools is a group of toolsfor compiling software from sources. 1yum -y groupinstall "Development Tools" Download Node.js source code. Navigate to /usr/src directory, download thesource file.You can find the latest Node.js source code in Node.js Official Download Page. 123456cd /usr/srcwget http://nodejs.org/dist/v0.10.29/node-v0.10.29.tar.gz# uncompress the tarballtar zxf node-v0.10.29.tar.gzcd node-v0.10.29 Now we are ready to install. 123./configuremakemake install After the install process done, run node -v to check if it was installed correctly. Note: to enable to run an executable in /usr/local/bin through sudo, youhave to add /usr/local/bin to your secure_path using visudo: 1sudo visudo Find the secure_path and add :/usr/local/bin to the end of the path string.Don’t forget the prefix colon. Reference: How To Install And Run A Node.js App On Centos 6.4 64bit]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Check CentOS system version]]></title>
      <url>%2F2014%2Fcheck-centos-version%2F</url>
      <content type="text"><![CDATA[Login to your CentOS server using SSH and run: 1234cat /etc/centos-release# ORcat /etc/redhat-release]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Transfer files using scp]]></title>
      <url>%2F2014%2Ftransfer-files-using-scp%2F</url>
      <content type="text"><![CDATA[command: scp &lt;from&gt; &lt;to&gt; Fetch files from Remote Server: 12345# Fetch a filescp user@remote-server:/home/username/file.zip ~/downloads/file.zip# Fetch a directoryscp -r user@remote-server:/home/user/dir ~/downloads/dir Upload files to Remote Server: 12scp ~/downloads/file.zip user@remote-server:/home/username/file.zipscp -r ~/downloads/dir user@remote-server:/home/username/dir For Windows, Use WinSCP]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript Array methods and Array-like Objects]]></title>
      <url>%2F2014%2Farray-like-objects-in-javascript%2F</url>
      <content type="text"><![CDATA[The JavaScript array methods are purposely defined to be generic, so that they work correctly when applied to array-like objects in addition to true arrays. In ECMAScript 5, all array methods are generic. In ECMAScript 3, all methods except toString() and toLocaleString() are generic. (The concat() method is an exception: although it can be invoked on an array-like object, it does not property expand that object into the returned array.) Since array-like objects do not inherit from Array.prototype, you cannot invoke array methods on them directly. You can invoke them indirectly using the Function.call method, however: // An array-like object var a = {&quot;0&quot;:&quot;a&quot;, &quot;1&quot;:&quot;b&quot;, &quot;2&quot;:&quot;c&quot;, length:3}; Array.prototype.join.call(a, &quot;+&quot;); // =&gt; &quot;a+b+c&quot; Array.prototype.slice.call(a, 0); // =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]: true array copy Array.prototype.map.call(a, function(x) { return x.toUpperCase(); // =&gt; [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;] }) JavaScript: The Definitive Guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript版本简要概述]]></title>
      <url>%2F2014%2Fjavascript-versions-summary%2F</url>
      <content type="text"><![CDATA[谈及JavaScript版本时，可能与早几年浏览器大战时对于JavaScript的实现一样让人困惑。比如，可能会看到JavaScript 1.5, JavaScript 2.0, ECMAScript 3, JScript 5诸如此类的。 了解JavaScript版本的信息，看似毫无必要。但知己知彼百战不殆，了解JavaScript代码运行的环境所支持的版本，可以编写出更为高效的代码。《Effective JavaScript》第一条，Know which JavaScript you are using。 版本信息在经过一番资料的检索后，我发现Wiki上ECMAScript词条下有一个JavaScript版本的对应图表很直观的说明各个版本称呼之间的关系（图表有缩减）： JavaScript JScript ECMAScript 1.0 (Netscape 2.0) 1.0 IE 3.0 1.3 (Netscape 4.06-4.7x) 3.0 (IE 4.0) Edition 1, Edition 2 1.5 (Netscape 6.0) 5.5 (IE 5.5) Edition 3 1.6 - 1.8 Edition 3 + extras JavaScript 2.0 Harmony JavaScript最初由Netscape推出，在其Netscape Navigator上使用，并一直使用”JavaScript X.X”的版本，后Mozilla沿用这种版本信息。JScript是Microsoft在Netscape推出JavaScript不久后，在自家产品Internet Explorer上推出的脚本语言。为了避免商标授权问题，将其称为JScript。之后，为了保证统一性，便产生了ECMAScript。ECMAScript目前有1、2、3、5、6，五个版本。ECMAScript 6预计在2014年年底发布。 值得一提的是，ECMAScript 4并未发布，被打回重审，最后被ECMAScript 6取代。关于这点可以在Wiki ECMAScript词条下的ECMAScript 4和ECMAScript 6中看出端倪。 浏览器的实现情况对于浏览器的支持情况，先看John Resig大神总结的博文。我将其中浏览器支持的情况整理成一个表格： Product Supports JavaScript IE 6-7 JScript5(= ECMAScript3, JavaScript 1.5) IE 8 JScript6(= ECMAScript3, JavaScript 1.5) Bug fixes over JScript5 Firefox 1.0 JavaScript 1.5(= ECMAScript3) Firefox 1.5 JavaScript 1.6 (1.5 + Array Extras + E4X + misc.) Firefox 2.0 JavaScript 1.7 (1.6 + Generator + Iterators + let + misc.) Firefox 3.0 JavaScript 1.8 (1.7 + Generator Expressions + Expression Closures + misc.) Opera A language that is equivalent to ECMAScript 3 + Getters and Setters + misc. Safari A language that is equivalent to ECMAScript 3 + Getters and Setters + misc. 浏览器更新日新月异，这份2008年的表格唯一能体现就是：ECMAScript 3在当前浏览器市场有广泛的支持。到这份日志写作时间，可以查到目前浏览器版本对JavaScript的支持情况为： Product Version tested Test262 failed Test suite version (date) Google Chrome 35.0.1916.114 m 11/11578 ES5.1 (2013-06-13) Mozilla Firefox 29.0.1 48/11578 ES5.1 (2013-06-13) Mozilla Firefox 24.5.0 ESR 75/11578 ES5.1 (2013-06-13) Internet Explorer 11.0.8 (11.0.9600.17107) 7/11578 ES5.1 (2013-06-13) Internet Explorer 10.0.16 (10.0.9200.16899) 8/11578 ES5.1 (2013-06-13) Maxthon 4.4.0.4000 11/11578 ES5.1 (2013-06-13) Opera 21.0.1432.67 11/11578 ES5.1 (2013-06-13) Opera 12.17 / 12.16 11/11578 ES5.1 (2013-06-13) Safari 7.0 (9537.71) 8/11578 ES5.1 (2013-06-13) 可以看到新版的浏览器绝大多数已经支持ECMAScript 5。关于浏览器对于ECMAScript 5的支持情况，特别是细化到各项feature，可以参考这份文档（以及ECMAScript 6的支持情况）。 对于不支持ECMAScript 5的浏览器（比如说IE 6/7）可以考虑使用ES5 Shim库来解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Check npm packages version]]></title>
      <url>%2F2014%2Fcheck-npm-packages-version%2F</url>
      <content type="text"><![CDATA[查看包的版本信息 1npm view &lt;package-name&gt; version view命令也可以查看其他的包属性，例如： 12345678// 查看包的依赖npm view &lt;package-name&gt; dependencies// 查看包的源码仓库地址npm view &lt;package-name&gt; repository.url// 贡献者E-mail地址npm view &lt;package-name&gt; contributes.email]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[System-wide proxy on windows7]]></title>
      <url>%2F2014%2Fsystem-wide-proxy-on-windows7%2F</url>
      <content type="text"><![CDATA[在Windows7上做全局代理，需要两个步骤： 在IE的选项中设置proxy的信息 在命令行中使用netsh来设置全局走代理 netsh设置的命令为： 1234567netsh winhttp import proxy source=ie# 查看proxy设定netsh winhttp show proxy# 重置proxy设定netsh winhttp reset proxy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[List installed npm packages]]></title>
      <url>%2F2014%2Flist-npm-packages%2F</url>
      <content type="text"><![CDATA[使用npm list列出已安装的模块，指定depth=0过滤掉子依赖模块。适用-g选项来查看安装在全局的模块： 1234npm list --depth=0//列出安装在全局的模块npm list -g --depth=0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2014%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in trobuleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[唔，问乃一时之耻，不问乃一生之耻]]></title>
      <url>%2F2014%2Fask-or-not-to-ask%2F</url>
      <content type="text"><![CDATA[唔，问乃一时之耻，不问乃一生之耻 村上春树 —— 海边的卡夫卡]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用HTML 5语义化标签]]></title>
      <url>%2F2014%2Fusing-html5-tags%2F</url>
      <content type="text"><![CDATA[为了在主流浏览器上使用HTML 5语义化标签，需要做一些修正，本文便是对这些修正原理的解释。如果你正在寻找一个快速的解决方案，可以看以下HTML5 Shiv这个库。下载这个库的代码，然后在页面的head中使用以下代码即可： 123&lt;!--[if lt IE 9]&gt; &lt;script type="text/javascript" src="path/to/html5-shiv.js&gt;&lt;/script&gt;&lt;![endif]--&gt; 如果看看这个代码背后的原理，请继续往下。 HTML 5语义化标签简述语义化标签，顾名思义，是具备一定语义的标签。比如，当使用ol标签，语义就是创建一个有序的列表。语义化可以增强页面的可访问性。 一个页面通常会被划分成几个区域，比如头部，边栏，内容区域以及底部。在HTML 5之前，页面的结构代码看起来类似于： 123456&lt;div id="header"&gt;&lt;/div&gt;&lt;div id="main"&gt; &lt;div id="sidebar"&gt;&lt;/div&gt; &lt;div id="article"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="footer"&gt;&lt;/div&gt; 由于这些结构划分的通用性，HTML 5引入了几个具有此类语义的标签： 1header, main, aside, article, footer 使用这些标签重写上面的页面： 123456&lt;header&gt;&lt;/header&gt;&lt;main&gt; &lt;aside&gt;&lt;/aside&gt; &lt;article&gt;&lt;/article&gt;&lt;/main&gt;&lt;footer&gt;&lt;/footer&gt; 新标签与旧浏览器的冲突有些浏览器早于HTML 5草案发布，所以这些浏览器可能不支持这些新的标签。这就存在着一个问题，那就是浏览器对于未知的标签（元素）是如何处理？这个问题可以再细分为两个子问题： 如何处理未知元素的样式 如何处理未知元素在DOM树中的位置 不同的浏览器对于这两点的处理是不同的，特别在老版本的IE中存在特殊的行为。 第一个修正针对第一条（即未知元素的样式），对于浏览器来说，最为简单的做法是不对未知元素的样式做任何处理。浏览器会给已知元素设置一些默认的样式，比如i标签，默认是斜体，p标签具有前后留白等。而对于未知元素，浏览器没有给定任何的默认样式，由页面作者自定义其样式。 但需要注意的是，浏览器会将未知元素认为是inline级别。所以对于旧版本的浏览器做的修正是明确指定新标签的display规则： 123header, main, aside, article, footer &#123; display: block;&#125; 针对IE的处理事情还未结束，因为IE 9之前的版本对于未知元素的处理存在着两个问题： 无法应用样式到未知元素上 错误地解析未知元素为空节点 第一个问题是，即使在样式表中指定了未知元素的样式规则，同样无法生效。 第二个问题从解析后的DOM结构来看很明了。假定有如下的代码： 1234&lt;article&gt; &lt;h1&gt;Welcome to Initech&lt;/h1&gt; &lt;p&gt;This is your&lt;/p&gt;&lt;/article&gt; 正确的渲染之后是如下的结构： article | +--h1 (article子节点) | | | +--text node &quot;Welcome to Initech&quot; | +--p (article子节点) | +--text node &quot;This is your &quot; 在IE 9之前的版本中，article标签（未知元素）将被解析成一个空的标签，其子元素成为这个未知元素的相邻节点： article (空节点) h1 (article相邻节点) | +--text node &quot;Welcome to Initech&quot; p (article相邻节点) | +--text node &quot;This is your &quot; 幸运的是，IE中这两个问题可以很简单的被修正。 对于未知元素，在页面渲染前使用document.createElement()这个方法创建一次即可，不用注入到页面上。例如： 1document.createElement("article"); 需要注意的是，必须在浏览器解析未知元素之前使用这个方法。所以建议是将这个hotfix放置在页面的head区域中。 小結为了在兼容当前主流浏览器的情况下使用HTML 5新的语义标签，需要做两个处理： 明确指定新标签的display属性 header, main, aside, article, footer { display: block; } 针对IE 9以下版本的浏览器做处理。在页面head区域，使用以下代码： &lt;!--[if lt IE 9]&gt; &lt;script type=&quot;text/javascript&quot;&gt; var e = (&quot;abbr,article,aside,audio,canvas,datalist,details,&quot; + &quot;figure,footer,header,hgroup,mark,menu,meter,nav,output,&quot; + &quot;progress,section,time,video&quot;).split(&apos;,&apos;); for (var i = 0; i &lt; e.length; i++) { document.createElement(e[i]); } &lt;/script&gt; &lt;![endif]--&gt; 以上。 参考资料 A LONG DIGRESSION INTO HOW BROWSERS HANDLE UNKNOWN ELEMENTS The Story of the HTML5 Shiv html5shiv Repo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Damn hard to take the right way]]></title>
      <url>%2F2014%2Fdamn-hard-to-take-the-right-way%2F</url>
      <content type="text"><![CDATA[Now I have to come to the crossroads in my life. I always knew what the right path was. Without exception, I knew, but I never took it. You know why? It was too damn hard! 女人香]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[If you can't explain it simply, you don't understand it well enough.]]></title>
      <url>%2F2014%2Fif-you-cant-explain-it-simply-you-dont-understand-it-well-enough.%2F</url>
      <content type="text"><![CDATA[If you can’t explain it simply, you don’t understand it well enough. Albert Einstein]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Learn Vimscript the Hard Way]]></title>
      <url>%2F2013%2Flearn-vimscript-the-hard-way%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Grunt - Cannot read property 'srcRaw' of undefined]]></title>
      <url>%2F2013%2Fgrunt-cannot-read-property-srcraw-of-undefeind%2F</url>
      <content type="text"><![CDATA[今天看到grunt的github issues里面有人提到了这个问题，想起之前刚接触grunt时也曾碰到。 问题的原因在于grunt从0.3升级到0.4之后，文件的处理发生了改变（使用this.files api）。所以如果使用0.4版本的grunt，要确认Plugins是否与其兼容。 Issues里，shama提供了一种解决方案： npm cache clean npm install grunt@master grunt-contrib-concat@master 附： grunt 0.3到0.4的升级说明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Simple AngularJS Demo (Compare with jQuery)]]></title>
      <url>%2F2013%2Fsimple-angularjs-example%2F</url>
      <content type="text"><![CDATA[这是一个简单的示例，演示一个段落(p)的内容随着输入框(input[type=&quot;text&quot;])内容的改变而变。输入框中的内容可能因两个因素改变： 用户输入 服务器数据更新 示例的原理就是监听输入框的内容，如果输入框内容发生改变，那么对应更新段落对应的内容。 下载Demo文件 使用jQuery来实现监听输入框的内容以及改变对应段落的内容之前，需要先获取他们的DOM引用，所以在HTML设定ID或者Class作为钩子。将HTML结构设定为： &lt;div&gt; &lt;input id=&quot;customGreetingText&quot; type=&quot;text&quot; /&gt; &lt;p&gt; &lt;span id=&quot;greetingText&quot;&gt;Hello&lt;/span&gt;, World! &lt;/p&gt; &lt;button id=&quot;updateGreetingText&quot;&gt;Update&lt;/button&gt; &lt;/div&gt; ... &lt;script src=&quot;../jquery.js&quot;&gt;&lt;/script&gt; 上述代码中，定义了一个id为customGreetingText的input元素、一个id为greetingText的span元素以及id为updateGreetingText的按钮。 按照此前所述原理，需要监听input内容的改变。那么在使用jQuery的脚本里，就需要为input的change和keyup事件注册回调函数，当用户输入keyup或者服务器数据更新时change事件发生，更新对应段落的代码： (function () { var customGreetingText = $(&quot;#customGreetingText&quot;); // Register a change listener on the input field customGreetingText .on(&quot;change&quot;, updateGreetingText) .on(&quot;keyup&quot;, updateGreetingText); // Mock the scenario that content changed by data from server. $(&quot;#updateGreetingText&quot;).on(&quot;click&quot;, function () { setTimeout(function () { customGreetingText.val(&quot;Hi&quot;).trigger(&quot;change&quot;); }, 1000); }); function updateGreetingText() { $(&quot;#greetingText&quot;).html(this.value); } }()); 上述代码中，通过点击按钮button#updateGreetingText使用setTimeout来模拟从服务器获取数据更新的操作。 使用AngularJS来实现与jQuery不同的是，在使用AngularJS时，不需要为元素定义ID或Class钩子。HTML代码变的更为简洁： &lt;div&gt; &lt;input id=&quot;customGreetingText&quot; type=&quot;text&quot; /&gt; &lt;p&gt; &lt;span id=&quot;greetingText&quot;&gt;Hello&lt;/span&gt;, World! &lt;/p&gt; &lt;button id=&quot;updateGreetingText&quot;&gt;Update&lt;/button&gt; &lt;/div&gt; ... &lt;script src=&quot;../jquery.js&quot;&gt;&lt;/script&gt; 注意到，在HTML结构上有稍许的变化： 根元素html有一个ng-app的属性 包含容器div有一个ng-controller=&quot;HelloController&quot;的属性 输入框input有一个ng-model=&quot;greeting.text&quot;的属性 按钮button由一个ng-click=&quot;update()&quot;的属性 这些属性在AngularJS中称为directive，用于扩展HTML DOM。其中： ng-app指明AngularJS将在这个元素($rootScope)及其子元素中生效； ng-controller顾名思义，指定View对应的Controller，此例子中为HelloController； ng-model指定input与greeting对象的text属性之间进行双向绑定（即View中的内容发生改变时greeting.text发生改变，反之亦然）； `{{}}`表示greeting对象的text属性单向绑定到View（即greeting.text发生改变时，View的内容也发生改变，反之无效）； 最后，ng-click指明当button被点击时，执行了update()回掉函数。 完成HTML结构定义后，定义HelloController： function HelloController($scope, $timeout) { $scope.greeting = { text: &quot;Hello&quot; }; // Update data from server. $scope.update = function () { $timeout(function () { $scope.greeting.text = &quot;Hi&quot;; }, 1000); }; } 在DOM Ready之后，Angular将执行HelloController中的内容。 在HelloController中，设定greeting对象为$scope的属性，同时定义了update函数为$scope的方法。$scope是Controller和View之间的粘合剂，Controller给$scope对象设定属性或者方法，View通过$scope获取数据。 可以看到在HelloController构造函数有两个以$开头的参数$scope和$timeout。在AngularJS中，这个称为service($scope和$timeout为内建的service)，service用于封装通用的代码，比如$http服务，封装了网络操作相关的代码。 与jQuery明显不同的是，JavaScript代码中没有明确地注册input交互事件的监听函数，这一切都由AngularJS在内部完成，借助于数据绑定，当输入框内容发生变化时，段落的内容也会发生改变。 而这正是AngularJS神奇的开始。 下载Demo文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用网盘（Dropbox/Google Drive）同步Git仓库]]></title>
      <url>%2F2013%2Fsync-git-repos-in-cloud%2F</url>
      <content type="text"><![CDATA[还在使用老掉牙的U盘搬运代码（文件）的方式，从一台机器上复制后，粘贴到另一台机器上？太Out了。使用Github 倒是一个非常不错的替代方法。但无论是基于什么理由都有可能不想把代码公开（毕竟Github免费账户是无法建立Private Repository）。建立Private Repository？Bitbucket免费账户同样有私有的仓库。不过，在云概念满天飞的时代，免费网盘满大街随手都可以捡到一个。为何不能使用网盘来保存Git项目文件？ 网盘选择对于网盘的要求无非是免费、量大（免费还要量大？用户真是太苛刻了）以及安全可靠。首推的当然是口碑极佳的Dropbox，但由于某些原因导致Dropbox的客户端下载有些技术难度，庆幸的是同步没有问题，但与国内网盘相比速度上可能稍差。另外一个不错的选择是Google Drive，免费15G，可靠性有保证。除此之外，理论上只要支持以「.」开头的文件的网盘都可以用来同步Git项目。 具体设定做法分为三步：初始化本地Git仓库；在网盘中新建一个空的Git仓库；设定网盘中的Git仓库为远程仓库。具体操作步骤如下： 初始化本地Git仓库 cd ExampleProject # 定位到项目目录中 git init # 本地Git仓库初始化 git commit -a -m &quot;Initial Commit&quot; # 初次提交，本地仓库创建完成 在网盘中新建一个空的Git仓库 cd CloudStorage # 定位到网盘所在目录CloudStorage下 git init --bare ExampleProject.git # 新建空的Git仓库 将网盘中的Git仓库作为远程仓库 cd ExampleProject # 定位到项目目录 git remote add cloud CloudStorage/ExampleProject.git # 添加远程仓库 git push -u cloud master # 推送本地修改到远程修改 设定完成。 多台设备同步其他设备上需要进行项目的修改时，首先使用网盘同步网盘的数据，假设网盘地址在d:/Documents/GoogleDrive。然后再clone项目到本地，clone的操作与cloneGithub上的项目大同小异（仓库地址不同）： git clone file:///d:/Documents/GoogleDrive/ExampleProject.git ExampleProject 上面的代码将checkout网盘中的项目，然后放在ExampleProject目录下。当在此台上修改了本地的代码并提交到本地仓库后，推送修改到远程仓库（网盘中的仓库），再让网盘进行同步，最后在其他机器上fetch/pull即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[译] 立即执行函数表达式（IIFE）]]></title>
      <url>%2F2013%2Fjavascript-iife%2F</url>
      <content type="text"><![CDATA[原文：Immediately-Invoked Function Expression (IIFE)作者：”Cowboy” Ben Alman 或许你没有注意到，我是一个对术语比较在意的人。所以，在听到许多次 JavaScript「自执行匿名函数」（self-executing anonymous function）或者「自调用匿名函数」（self-invoked anonymous function）这两个流行但令人误解的术语，我觉得得将我的想法写下来。 本文实际上除了提供详细关于这个模式的原理之外，还推荐了我们之后如何称呼这个模式。当然，你可以跳过关于这个推荐的内容，直接查看「立即执行函数表达式」的例子，但是我建议你完整地阅读本文。 请注意，本文并非是那种「我就是正确的，而你是错误」的论调。我真诚的希望帮助人们了解潜在的复杂的概念，并且深感使用一致并且精确的术语是一种非常有效的促进人们相互理解的方法。 那么，到底本文旨在何处？在 JavaScript 中，每一个函数被调用时都会创建一个执行上下文（execution context）。定义在函数内部的变量和函数都只能在这个执行上下文的内部访问到，所以函数提供了一种创建私有成员的便捷的方法。 123456789101112131415161718192021// makeCounter返回了另外一个内部函数。// 而这个内部函数可以访问私有变量i，所以这个内部函数实际上拥有一个特权（访问内部私有变量）function makeCounter() &#123; // `i`变量仅在`makeCounter`函数内部有效 var i = 0; return function () &#123; console.log(++i); &#125;;&#125;// 注意，`counter` 和 `counter2` 拥有各自的`i`var counter = makeCounter();counter(); // logs: 1counter(); // logs: 2var counter2 = makeCounter();counter2(); // logs: 1counter2(); // logs: 2i; // ReferenceError: i未定义（i仅在makeCounter中有效） [译注]：JSFiddle例子链接 在很多情况下，不论makeWhatever函数返回的是什么样的值，你希望这个值在每次返回都是相同的，或者，你根本不需要函数返回一个值。 问题的本质假若你定义了一个函数：function foo () {} 或者 var foo = function () {}，你都获得了一个函数的引用变量。可以在在这个变量使用括号操作符（parenthese）来调用函数，即：foo()。 123456// 像底下定义的函数可以在函数名之后放置括号()，比如foo()来调用。// 而foo仅仅是一个函数表达式`function()&#123; /* code */ &#125;`的引用。var foo = function () &#123; /* code */&#125;// 那么是否可以在函数表达式之后直接使用()来调用？function () &#123; /* code */ &#125;(); // SyntaxError: Unexpected token ( 上面代码执行后就会抛出一个错误（catch）。当脚本解释器在全局命名空间或者函数内部遇到关键字function的时候，默认地，解释器认为这是一个函数声明语句（function declaraction），而非函数表达式（function expression）。如果没有明确地告知解释器function(){}()是一个函数表达式，解释器将认为这是一个函数声明，并且声明没有指定函数的名字。由于函数声明时必需为指定函数的名称，所以解释器抛出语法错误（SyntaxError）。 函数，括号以及语法错误有趣的是，既然是由于缺乏函数名称而导致语法错误，那么只要指定一个函数名字不就通过了？解释器依然会抛出一个语法错误提示，但却是由于不同的原因。当括号放置在函数表达式后，此括号即为括号运算符，表示调用函数；然而当括号放置在语句之后意味着分离括号前面与括号中的内容，此时括号仅仅做为分组表示（即用于改变运算的优先关系）。 12345678910111213// 照理说底下语句是有效。但解释器认为这依然是一个函数声明语句。// 后面的括号是分组操作，由于括号中没有内容，所以解释器抛出异常。function foo()&#123; /* code */ &#125;(); // SyntaxError: Unexpected token )// 既然由于括号内没有内容导致异常，那么只要在括号内加入内容不就可以了...// 但是函数依然没有执行function foo()&#123; /* code */ &#125;( 1 );// 上面的语句等价与一个函数声明，紧接这一个与函数完全无关的表达式。// 这是解释器所看到的：function foo()&#123; /* code */ &#125;( 1 ); 你可以访问 Dmitry A. Soshnikove 对于此运算内容翔实的文章：ECMA-262-3 in detail. Chapter 5. Functions。 立即执行函数表达式（IIFE）幸运的是，可以简单地修复上述的语法错误问题。被广为接受的修复方式是使用括号明确告诉解释器这个是一个函数表达式。因为在JavaScript中，括号无法包含语句。因此，当解释器遇到括号中的function关键字时，将认为这是一个函数表达式，而非函数声明。 12345678910111213141516171819// 这两种写法都可以立即执行一个函数表达式，同时创建了一个私有作用域(function()&#123; /* code */ &#125;()); // Crockford 推荐这种写法(function()&#123; /* code */ &#125;)(); // 但是这种也一样有效// 由于括号或者强迫操作符用于让解释器可正确区分函数表达式与函数声明，所以在解释器可以正确区分的地方，括号就可以省略// 不过请查看下面的重要说明var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;();// 如果不在意函数的返回值或者不在意代码的可读性，使用一元操作符亦是有效的!function()&#123; /* code */ &#125;();~function()&#123; /* code */ &#125;();-function()&#123; /* code */ &#125;();+function()&#123; /* code */ &#125;();// 以下是另外一种形式（@kuvos提供）。new function()&#123; /* code */ &#125;new function()&#123; /* code */ &#125;() // 括号仅在传参时需要 关于上述代码中括号的一个重要说明虽然在上述那些括号可有可无（因为解释器可以正确地识别他们是函数表达式），但还是建议在赋值语句中带上括号，作为一种不成文的约定。 括号在这种情况下表示函数将会立即被执行，同时，执行结果返回的函数执行的结果而非函数本身。通过这个约定，碰到一个函数表达式时就没有必要滚动到函数表达式的末尾（函数可能非常长）去查看是否立即执行了这个函数。 根据以往的经验，编写清晰的代码在技术上可以避免JavaScript解释器抛语法错误异常，同时也可以避免遇到「屎一样的BUG」。 使用闭包（closures）保存状态实参可以传递给函数名（通过函数声明），也可以传递给立即调用的函数表达式。同时，函数（outer）可以在内部定义另外一个函数（inner），此时内部函数（inner）可以访问外部函数(outer)的传递进来参数和变量（这种关系被称为「闭包」）。结合上述的两种特性，我们可以使用「立即执行函数表达式」来锁定变量值并保存状态。 如果想要了解更多关于「闭包」的内容，请访问：Closures explained with JavaScript。 123456789101112131415161718192021222324252627282930313233343536// 底下例子不会按照你的预期工作，因为`i`的值没有被锁定。// 相反，当任意一个链接被点击时（在循环结束之后），弹出的值中i的值都等于elems.length。// 这是因为在链接被点击的时候（循环之后），`i`的值就是elems.lengthvar elems = document.getElementsByTagName('a');for (var i = 0; i &lt; elems.length; i++) &#123; elems[i].addEventListener('click', function (e) &#123; e.preventDefault(); alert('I am link #' + i); &#125;, 'false');&#125;// 这个例子如预期工作，因为在IIFE内部，`i`的值被锁定为`lockedInIndex`。// 即使在循环之后`i`的值为元素的总个数，但是在IIFE中，`lockedInIndex`的值永远都是IIFE被调用的时候传入的`i`的值。// 也就是说循环时每次传入的`i`(0, 1...)都在IIFE调用是固定为`lockedInIndex`，不会被改变。// 所以每个链接被点击时都获取到了期望的`i`值var elems = document.getElementsByTagName('a');for (var i = 0; i &lt; elems.length; i++) &#123; (function (lockedInIndex) &#123; elems[i].addEventListener('click', function (e) &#123; e.preventDefault(); alert('I am link #' + lockedInIndex); &#125;, 'false'); &#125;)(i);&#125;// 也可以采用这种方式。在click的回掉函数上使用IIFE锁定`i`的值并返回一个函数。// 两种方式都可以按照预期的想法工作。但是上面的例子更易阅读。var elems = document.getElementsByTagName('a');for (var i = 0; i &lt; elems.length; i++) &#123; elems[i].addEventListener('click', (function (lockedInIndex) &#123; return function (e) &#123; e.preventDefault(); alert('I am link #' + lockedInIndex); &#125;; &#125;)(i), 'false');&#125; 注意上述代码中的最后两个例子，lockedInIndex可以正确的使用i的值。使用lockedInIndex作为立即执行函数表达式的参数令代码看起来更易理解。 立即执行函数表达式的另外一个优点在于，由于立即执行函数表达式并未使用标识符来命名，即未命名或者匿名的，所以可以不污染全局命名空间的情况使用。 那么术语「自执行匿名函数」哪里不对？在上文中已经多次提到我所建议的术语「立即执行函数表达式」，或者简写为「IIFE」，但是并未明确说明。我将他念成「iffi」（亦非？）。 什么是「立即执行函数表达式」？顾名思义，她是一个被立即执行的函数表达式。 我很希望看到JavaScript社区接受「立即执行函数表达式」（IIFE），在他们的文章中使用这个术语。因为我觉得IIFE让这个概念更加清晰，也因为术语「自执行匿名函数」并不准确： 1234567891011121314151617181920212223// 这是一个「自执行函数」。函数在内部调用本身，形成递归。function foo() &#123; foo(); &#125;// 这是一个「自执行匿名函数」。因为没有命名，所以在函数内部使用arguments.callee来调用自身。var foo = function() &#123; arguments.callee(); &#125;;// 这应该就是一个所谓的「自执行匿名函数」了，但仅限于`foo`标识符引用这个函数。// 如果foo指向了其他的值，那么这个就成为了「曾经是自执行匿名函数」了。var foo = function() &#123; foo(); &#125;;// 这个语句被称为「自执行匿名函数」。但是她并非自执行，因为她根本没有调用她本身。这是一个立即执行函数。(function()&#123; /* code */ &#125;());// 为一个函数表达式指定名字在调试的时候异常有由，在调用栈里可以查找到。// 然后一旦指定名字，这就是一个非匿名函数了。(function foo()&#123; /* code */ &#125;());// IIFE同样可以调用自身，但或许这不是一个非常有用的形式。(function()&#123; arguments.callee(); &#125;());(function foo()&#123; foo(); &#125;());// 最后一提，以下这个语句在BlackBerry5中会异常，因为在一个具名函数内部，此变量引用的函数还未生成是undefined。有趣吧？(function foo()&#123; foo(); &#125;()); 希望上述的例子可以验证「自执行」这个词是令人误解的。虽然函数一样是执行了，但并非是函数执行她本身。同时，「匿名」也无须特别指出，因为一个立即执行函数表达式可以匿名也可以具有名字。最后，我比较喜欢「invoked」而非「executed」在于押韵，我想「IIFE」看起来念起来比「IEFE」顺。 这就是我的想法。 由于 arguments.callee 在 ECMAScript 5 strict mode 中已被弃用，所以从技术上说一个自执行匿名函数是不可能实现的。 模块模式（Module Pattern）当我在论述函数表达式的时候，可以漏掉了模块模式。若你对JavaScript里面的模块模式不熟悉的话，那么查看文中第一个例子，那个例子就是接近于模块模式。之所以说接近，是由于模块模式返回的是一个对象，而第一个例子返回的是函数。若第一个例子返回值改成一个对象，也就通常实现单例模式（Singleton Pattern）的方法，如下代码所示： 123456789101112131415161718192021222324252627282930// 创建一个立即执行的匿名函数表达式，并将函数的返回值赋予一个变量。// 与第一例子相比，这个方法略去了`makeWhatever`中间函数。// 就像上面重要提示中所述，尽管在这个例子中，外面的括号是非必需的。// 但加上括号可以明确这是以立即执行的函数，将函数的结果赋予变量，而非将函数赋予变量。var counter = (function () &#123; var i = 0; return &#123; get: function () &#123; return i; &#125;, set: function (val) &#123; i = val; &#125;, increment: function () &#123; return ++i; &#125; &#125;;&#125;());// `counter`是一个带有成员的对象，在此例中她的成员都是函数。counter.get(); // 0counter.set(3);counter.increment(); // 4counter.increment(); // 5counter.i; // undefined (`i` 并非`counter`的成员)i; // ReferenceError: i未定义 (仅存在于匿名函数表达式形成的私有作用域中，即闭包) [译注] 例子的JSFiddle链接 模块模式不仅仅强大并且简洁明了。使用很少的代码就可以有效地将方法和属性封装起来，与此同时不污染全局命名空间以及创建私有作用域。 扩展阅读希望本文可以解答你的一些疑虑。当然，若阅读完本文之后你的疑问比之前更多了，你可以阅读以下列表的文章以探索更多关于函数以及模块模式： ECMA-262-3 in detail. Chapter 5. Functions - Dmitry A. Soshinikov Functions and function scope - Mozilla Developer Network Named function expressions - Named function expressions - Juriy “kangax” Zaytsev JavaScript Module Pattern: In-Depth - JavaScript Module Pattern: In-Depth - Ben Cherry Closures explained with JavaScript - Nick Morgan 最后感谢 Asen Bozhilov 和 John David Dalton 的技术建议以及Nick Morgan的深刻见解。如果你由任何想法，请在评论里发表，谢谢！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试驱动开发实践：JavaScript 字符串的复制函数]]></title>
      <url>%2F2013%2Ftdd-in-practice-javascript-string-duplicate%2F</url>
      <content type="text"><![CDATA[在《测试驱动的JavaScript开发》一书第四章中提到「从测试中学习」，这是一个很值得推荐的学习方式。如果是为自己的应用代码设计断言编写测试，可以让我们在动手写代码之前清楚我们到底需要做什么，并且之后的重构可以有保证的进行；如果是为他人的应用代码设计断言编写测试，那将是很好的机会去学习他人的代码编写方式。 比如学习流行的 JavaScript 库的代码（例如 underscore.js ）的时候可以采用这种方法。为 underscore.js 的函数编写测试，让测试通过，然后再自己着手编写函数，再进行测试；然后再比对 underscore.js 里函数的实现。此方法一方面可以练习编程能力，同时可以学习流行库里久经考验的写法。 继上文「Qunit快速上手」之后，本文将展示一次测试驱动开发实践：实现一个复制字符串本身的函数。采用的单元测试工具是 QUnit。 测试驱动开发遵循四个迭代步骤： 编写测试代码 运行测试，观察测试失败 使测试通过 重构 步骤一、测试驱动，先编写测试JavaScript 字符串类（String）并未提供一个复制字符串本身的方法。我们要实现的是复制字符串本身，即函数应该可以将 &quot;abcd&quot; 复制成 n * &quot;abcd&quot;，其中 n 代表要复制的次数。从代码的角度来看就是： 1"abcd".duplicate(2); // "abcdabcd" 同时，当 n 的值小于等于 1 时，仅返还字符串本身。 1"abcd".duplicate(0); // "abcd" 这便是我们的断言。明确了函数的目标之后，我们就可以编写测试脚本（假定测试脚本名称为 string-test.js，并且与源码 string.js 在同一目录下）： 12345678910test("Function: duplicate", function() &#123; // 当 n &lt;= 1 时 equal("abcd".duplicate(-1), "abcd", "It should be 'abcd' when n &amp;lt; 1"); equal("abcd".duplicate(0), "abcd", "It should be 'abcd' when n &amp;lt; 1"); equal("abcd".duplicate(1), "abcd", "It should be 'abcd' when n = 1"); // 复制字符串 2 次、3次 equal("abcd".duplicate(2), "abcdabcd", "It should be 'abcdabcd'); equal("abcd".duplicate(3), "abcdabcdabcd", "It should be 'abcdabcdabcd');&#125;); 我们设计了 5 个断言。其中，前三个断言测试当 n 小于 1 的情况；最后两个测试是否正确的对字符串进行了 n 次复制。 步骤二、运行测试，观察测试失败这一步将确认测试用例，确保测试用例的准确性。在执行测试的 html 中（假设是 tests.html ）引用测试脚本： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;QUnit Example&lt;/title&gt; &lt;link rel="stylesheet" href="qunit/qunit.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="qunit"&gt;&lt;/div&gt; &lt;div id="qunit-fixture"&gt;&lt;/div&gt; &lt;script src="qunit/qunit.js"&gt;&lt;/script&gt; &lt;!-- 源文件 --&gt; &lt;!-- 测试脚本 --&gt; &lt;script src="string-test.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器中打开 tests.html 执行测试，可以看到测试失败了，因为我们还没有编写源代码。 步骤三、使测试通过有了测试的保证，此时，我们可以采用最为直接的方式来实现功能（假定源代码文件为 string.js）： 1234567891011121314151617(function()&#123; if (typeof String.prototype.duplicate !== "function") &#123; String.prototype.duplicate = function (n) &#123; var duplicated = ""; if (n &lt;= 1) &#123; return this.toString(); &#125; for (var i = 0; i &lt; n; i++) &#123; duplicated += this; &#125; return duplicated; &#125;; &#125;&#125;()); 新建一个字符串 duplicated ，循环 n 次，每次循环中添加待复制字符串（this）到 duplicated 中。 源代码编写完成后，在 tests.html 中引用源代码文件并在浏览器中运行测试。 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt; &lt;title&gt;QUnit Example&lt;/title&gt; &lt;link rel="stylesheet" href="qunit/qunit.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="qunit"&gt;&lt;/div&gt; &lt;div id="qunit-fixture"&gt;&lt;/div&gt; &lt;script src="qunit/qunit.js"&gt;&lt;/script&gt; &lt;!-- 源文件 --&gt; &lt;script src="string.js"&gt;&lt;/script&gt; &lt;!-- 测试脚本 --&gt; &lt;script src="string-test.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果有遇到断言失败，说明源代码中逻辑存在问题，需要进行检查修改。 步骤四、重构回看第三步的代码，在循环中每次让 duplicated 加上待复制字符串 this 。而 JavaScript 字符串的相加操作按照以下步骤进行： 创建存储 this 的字符串 创建存储 duplicated 当前值的字符串 创建存储 this + duplicated 结果的字符串 把 this 复制到结果字符串中 把 duplicated 当前的内容复制到结果字符串中 更新 duplicated，使他指向结果字符串 从步骤上可以看出字符串相加操作的效率偏低。所以考虑到数组的 join 方法，将代码重构如下： 1234567891011121314151617(function () &#123; if (typeof String.prototype.duplicate !== "function") &#123; String.prototype.duplicate = function (n) &#123; var duplicated = []; if (n &lt;= 1) &#123; return this.toString(); &#125; for (var i = 0; i &lt; n; i++) &#123; duplicated.push(this); &#125; return duplicated.join(""); &#125;; &#125;&#125;()); 重构的代码中，新建一个数组，循环n次将待复制的字符串添加到数组中，最后通过数组的 join 。再次运行测试，保证重构可以通过测试。 完成一次测试驱动迭代到这里就是一个测试驱动开发的完整迭代：编写测试——运行测试，观察失败——使测试通过——重构。 后续后续对于 duplicate 函数的修改都可以在 string-test.js 中用例的保证下进行安全的重构。比如我们再观察步骤四中重构后的代码：将待复制字符串作为数组的元素并采用数组的 join 方法将字符串连接以达到复制的目的。换种思路，如果我们能够将待复制字符串作为 join 方法的参数，那么只要新建一个长度为 n + 1 的数组就可以达到复制的目的。相比使用循环添加元素到数组中，后者从算法和代码量都可以达到精简！最终版本的 duplicated 方法如下： 1234567(function () &#123; if (typeof String.prototype.duplicate !== "function") &#123; String.prototype.duplicate = function (n) &#123; return n &lt;= 1 ? this.toString() : new Array(n+1).join(this); &#125;; &#125;&#125;()); 运行测试，确保重构的代码能够通过测试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[译] 使用对象字面量组织代码]]></title>
      <url>%2F2013%2Fusing-objects-to-orgnize-your-code%2F</url>
      <content type="text"><![CDATA[原文：Using Objects to Organize Your Code 本文是JSMag 2009年3月刊的一篇文章的改进版。 当你写过基于jQuery的代码应用片段后，开始着手开发交互更加复杂的应用时，你会发现代码很快变得杂乱并且难于调试。本文将展示如何使用对象字面量模式，依据功能行为来开发更加复杂的交互。 在过去的几年里，JavaScript库让了初级开发者可以快速在他们的站点做出精细的交互。一些库，比如jQuery，拥有非常简单的语法，让零经验的开发者也能够快速的做出花哨的页面。这些花哨的特效，其中不乏精细之作，大多数实现只要在Google上花些时间就能找到。复制粘贴，使用一个插件再加上一些自定义代码，组成的页面看起来就很不错，然后就可以在简历上将jQuery加入技能之列。 但是，需求总在不断改变。之前实现的代码现在需要在三个元素或者是个元素上应用；之前的代码需要在另外一个仅有一些轻微不同（比如ID不同）的应用上重用……我们已经看到那些可以复制粘贴实现花哨功能的代码片段让jQuery（以及其他JavaScript库）看起来十分易用。但这些代码片段之外（这些代码片段仅仅是代码片段，对吧？），你还需要去设计组织你的代码当你需要的不仅仅是引用一个插件或者做一些show()/hide()。 对象字面量模式对象字面量模式可以根据功能组成来组织代码。同时，这个模式可以保证代码不会「污染全局命名空间」，不污染全局命名空间被认为是适用于所有项目，特别在大型项目中的一个最佳实践。这个模式强迫你在着手编写代码之前思考代码将做什么以及怎么做。对象字面量模式可以封装所有相关的行为，如下代码所示： 123456789var myObjectLiteral = &#123; myBehavior1 : function() &#123; /* do something */ &#125;, myBehavior2 : function() &#123; /* do something else */ &#125;&#125;; 现在来看一个例子：假设有一个#myFeatrue列表，当列表的的项被点击时，显示/隐藏项的子元素div中的内容，同时隐藏其他项的内容。实现的jQuery代码片段如下所示： 123456789101112$(document).ready(function() &#123; $('#myFeature li') .append('&lt;div/&gt;') .each(function() &#123; $(this).find('div') .load('foo.php?item=' + $(this).attr('id')); &#125;) .click(function() &#123; $(this).find('div').show(); $(this).siblings().find('div').hide(); &#125;);&#125;); 非常简单。但是，上面的例子中有几个地方后面可能会被改动。比如说，URL的构成方法、内容的存放位置以及显示隐藏的特效。使用对象字面量的方法，可以上述的需求更加简明，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839var myFeature = &#123; config : &#123; wrapper : '#myFeature', container : 'div', urlBase : 'foo.php?item=' &#125;, init : function(config) &#123; $.extend(myFeature.config, config); $(myFeature.config.wrapper).find('li'). each(function() &#123; myFeature.getContent($(this)); &#125;). click(function() &#123; myFeature.showContent($(this)); &#125;); &#125;, buildUrl : function($li) &#123; return myFeature.config.urlBase + $li.attr('id'); &#125;, getContent : function($li) &#123; $li.append(myFeature.config.container); var url = myFeature.buildUrl($li); $li.find(myFeature.config.container).load(url); &#125;, showContent : function($li) &#123; $li.find('div').show(); myFeature.hideContent($li.siblings()); &#125;, hideContent : function($elements) &#123; $elements.find('div').hide(); &#125;&#125;;$(document).ready(function() &#123; myFeature.init(); &#125;); 在如此简单的例子上，使用如上所述的对象字面量方法反而使代码显得更加冗长。坦白的讲，对象字面量方法并不会让代码更为精简，他所擅长的让你不会因维护代码而头痛。通过使用对象字面量模式，我们将代码分成各个逻辑部分，从而更容易的定位潜在易被修改的代码。同时，我们提供了默认的配置参数并且可以通过init方法（传入config对象）进行修改，让代码更易扩展。最后，这段代码的结构具备一定的自解释能力，可以快速的看出这段代码的用途。当以下需求不断变化改进的时候，此方法的益处将越来越明显。 注：推荐一本学习JavaScript对象、属性和方法的书籍：《Object-Oriented JavaScript: Create scalable, reusable high-quality JavaScript applications and libraries》，由Stoyan Stefanov著。你可能也需要了解JSON（JavaScript Object Notation）的知识。 更深入的例子[译注] JSFiddle完整例子 在这个例子中，我们的任务要创建一个由多个区域（Section）组成的UI，每个区域（Section）包含着多个内容。任意点击一个区域将会显示此区域底下的列表；点击列表项将会在显示对应的内容。当一个区域显示的时候，区域中的第一个列表项应该被展示。当页面载入完成时，第一个区域应该被展示。 第一步、构建HTML结构良好的HTML代码是编写优秀JavaScript代码的重要前提，所以这一步我们开始思考如何构建需求对应的HTML代码。HTML代码应该具备： 当JavaScript被禁用时，亦可正常工作 提供明了的DOM结构，以便JavaScript调用 避免多余的ID和class属性（你可能意料不到我们需要的id/class属性是如此之少） 有了上述的准则之后，我们着手编写HTML(JSFiddle预览地址)： 123456789101112131415161718192021222324252627282930313233343536373839&lt;h1&gt;This is My Nifty Feature&lt;/h1&gt;&lt;div id="myFeature"&gt; &lt;ul class="sections"&gt; &lt;li&gt; &lt;h2&gt;&lt;a href="/section/1"&gt;Section 1&lt;/a&gt;&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;h3&gt;&lt;a href="/section/1/content/1"&gt;Section 1 Title 1&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;The excerpt content for Content Item 1&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h3&gt;&lt;a href="/section/1/content/2"&gt;Section 1 Title 2&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;The excerpt content for Content Item 2&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h3&gt;&lt;a href="/section/1/content/3"&gt;Section 1 Title 3&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;The excerpt content for Content Item 3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;&lt;a href="/section/2"&gt;Section 2&lt;/a&gt;&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;h3&gt;&lt;a href="/section/2/content/1"&gt;Section 2 Title 1&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;The excerpt content for Content Item 1&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;h3&gt;&lt;a href="/section/2/content/2"&gt;Section 2 Title 2&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;The excerpt content for Content Item 2&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;h3&gt;&lt;a href="/section/2/content/3"&gt;Section 2 Title 3&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;The excerpt content for Content Item 3&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;&lt;a href="/section/3"&gt;Section 3&lt;/a&gt;&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;h3&gt;&lt;a href="/section/3/content/1"&gt;Section 3 Title 1&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;The excerpt content for Content Item 1&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;h3&gt;&lt;a href="/section/3/content/2"&gt;Section 3 Title 2&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;The excerpt content for Content Item 2&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;h3&gt;&lt;a href="/section/3/content/3"&gt;Section 3 Title 3&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;The excerpt content for Content Item 3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 上述代码中并没有包含区域导航和列表项导航的代码，导航的代码将由jQuery生成，因为他们仅在jQuery下有效，没有启用JavaScript的用户依然会看到有效的HTML。（如果上述代码中有不明的地方，那么现在可能是一个很好的时机去重温POSH(Plain-old semantic HTML) 以及 渐进增强）。 [译注] JSFiddle完整例子 第二步、搭建对象创建对象的第一步是在对象中创建「桩」。桩也就是占位符，他们描绘出我们要创建的对象的轮廓。待创建的对象拥有以下方法： myFeature.int()方法：将会在$(document).ready()的时候运行。此方法是应用的入口。 myFeature.buildSectionNav()方法：将会在MyFeature.init()方法中被调用。这个方法包含一个jQuery对象，这个jQuery对象包含所有区域（Section），并使用这些区域生成一级导航。这个方法中将会在生成的一级导航上注册事件，使得一级导航的项被点击时显示对应的区域。 myFeature.buildItemNav()方法：将会被myFeature.showSection()调用。这个方法包含一个jQuery对象，这个jQuery对象引用区域中列表的所有项，并使用这些项来生成二级导航。这个方法会在二级导航上注册事件，当项被点击时显示对应的内容。 myFeature.showSection()方法：在用户点击一级导航项的时候被调用。这个方法根据被点击的项来显示对应的区域。 myFeature.showContentItem()方法：在用户点击二级导航项的时候被调用。这个方法根据被点击的二级导航项来显示对应的内容。 同时我们在对象里定义了一个属性：myFeature.config。这个属性用来保存默认的配置。通关过给myFeature.init()方法传config来覆盖默认的配置。 12345678var myFeature = &#123; 'config' : &#123; &#125;, 'init' : function() &#123; &#125;, 'buildSectionNav' : function() &#123; &#125;, 'buildItemNav' : function() &#123; &#125;, 'showSection' : function() &#123; &#125;, 'showContentItem' : function() &#123; &#125;&#125;; [译注] JSFiddle完整例子 第三步、对象的实现当创建了对象的轮廓之后，就可以开始编码了。首先从建立myFeature.config属性以及myFeature.init()方法入手： 12345678910111213141516171819202122232425262728293031323334353637383940'config': &#123; // 默认的容器是 #myFeature 'container': $('#myFeature')&#125;,'init': function (config) &#123; // 自定义配置可以init的config参数配置 if (config &amp;&amp; typeof (config) == 'object') &#123; $.extend(myFeature.config, config); &#125; // 创建 或者 缓存dom元素。这些元素在后续代码中使用 myFeature.$container = myFeature.config.container; myFeature.$sections = myFeature.$container. // 仅选择直接子元素 find('ul.sections &gt; li'); myFeature.$section_nav = $('&lt;p/&gt;') .attr('id', 'section_nav') .prependTo(myFeature.$container); myFeature.$item_nav = $('&lt;p/&gt;') .attr('id', 'item_nav') .insertAfter(myFeature.$section_nav); myFeature.$content = $('&lt;p/&gt;') .attr('id', 'content') .insertAfter(myFeature.$item_nav); // 构建一级导航，并且触发第一个列表元素的点击事件 myFeature.buildSectionNav(myFeature.$sections); myFeature.$section_nav.find('li:first').click(); // 隐藏原始的HTML代码 myFeature.$container.find('ul.sections').hide(); // 设定属性initialized标识对象已被初始化。本例中没有用到，但这是一个很方便的属性 myFeature.initialized = true;&#125; 接着，创建myFeature.buildSetionNav()方法，创建一级导航： 1234567891011121314151617181920212223'buildSectionNav': function ($sections) &#123; // 迭代区域的列表项 $sections.each(function () &#123; // 获取当前区域引用 var $section = $(this); // 创建一级导航列表项 $('&lt;li/&gt;') // 使用h2的文本作为导航项的标题 .text($section.find('h2:first').text()) // 将此列表项添加到一级导航元素下 .appendTo(myFeature.$section_nav) // 使用data属性在新创建的列表项上存储一个到原始区域的引用 .data('section', $section) // 为此列表项创建点击回调函数 .click(myFeature.showSection); &#125;);&#125; 创建myFeature.buildItemNav()方法，创建二级导航： 123456789101112131415161718192021'buildItemNav': function() &#123; // 迭代区域内容项 $items.each(function () &#123; // 当前内容项的引用 var $item = $(this); // 创建一个列表项元素 $('&lt;li&gt;') // 使用第一个h3元素的文本作为列表项的标题 .text($item.find('h3:first').text()) // 添加列表想到二级导航上 .appendTo(myFeature.$item_nav) // 使用data()方法在列表项上存储一个到原始内容项的引用 .data('item', $item) // 绑定点击事件 .click(myFeature.showContentItem); &#125;);&#125; 最后，实现显示区域和内容的方法，myFeature.showSection()和showContentItem()： 1234567891011121314151617181920212223242526272829303132333435363738'showSection': function () &#123; // 当前被点击的列表项 var $li = $(this); // 清理导航以及内容区域 myFeature.$item_nav.empty(); myFeature.$content.empty(); // 使用data()获取data-section上存储的区域的引用 var $section = $li.data('section'); // 标记列表项为当前项，将列表中标注为当前项的元素移除标记 $li.addClass('current') .siblings().removeClass('current'); // 寻找与此区域有关的列表项 var $items = $section.find('ul li'); // 构建此区域的二级导航 myFeature.buildItemNav($items); // 触发第一个元素的'click'事件 myFeature.$item_nav.find('li:first').click();&#125;,'showContentItem': function () &#123; var $li = $(this); // 从此列表项的相领元素中移除'current'标记，并给当前元素加上'current'标记 $li.addClass('current') .siblings().removeClass('current'); // 使用data()方法获取data-item属性中存储的内容项的引用 var $item = $li.data('item'); // 使用内容项的内容填充内容区域 myFeature.$content.html($item.html());&#125; 对象已创建完成，剩下所需要做的就是在document ready的时候调用myFeature.init方法： 1$(document).ready(myFeature.init); [译注] JSFiddle完整例子 第四步、应对更改的需求项目总在最后关头做出一些需求上的调整，对吧？这就是对象字面量模式发挥的时候，这个模式可以使你快速不加班地实现更改。在上面的例子中，假若我们要通过AJAX获取数据而非HTML中获取，将会如何？假设后端已经就绪，可以接收前端的请求，代码将调整如下： 123456789101112131415161718192021222324252627282930var myFeature = &#123; 'config' : &#123; 'container' : $('#myFeature'), // 指定获取内容的函数 'getItemURL' : function($item) &#123; return $item.find('a:first').attr('href'); &#125; &#125;, 'init' : function(config) &#123; // stays the same &#125;, 'buildSectionNav' : function($sections) &#123; // stays the same &#125;, 'buildItemNav' : function($items) &#123; // stays the same &#125;, 'showSection' : function() &#123; // stays the same &#125;, 'showContentItem' : function() &#123; var $li = $(this); $li.addClass('current'). siblings().removeClass('current'); var $item = $li.data('item'); var url = myFeature.config.getItemURL($item); // 从url中load，而非$item.html() myFeature.$content.load(url); &#125;&#125;; 需要应用更具灵活性？可以通过配置默认参数的形式来实现。比如，通过myFeature.config配置如何寻找并生成二级导航列表项的标题： 12345678910111213141516171819202122232425262728293031323334353637var myFeature = &#123; 'config': &#123; 'container': $('#myFeature'), // 指定一级导航项标题的文本出处 'itemNavSelector': 'h3', // 指定处理导航标题的函数 'itemNavProcessor': function ($selection) &#123; return 'Preview of ' + $selection.eq(0).text(); &#125; &#125;, 'init': function (config) &#123; // stays the same &#125;, 'buildSectionNav': function ($sections) &#123; // stays the same &#125;, 'buildItemNav': function ($items) &#123; $items.each(function () &#123; var $item = $(this); // 使用config中指定的属性生成导航标题 var myText = myFeature.config.itemNavProcessor( $item.find(myFeature.config.itemNavSelector)); $('&lt;li/&gt;') // 设置标题 .text(myText) .appendTo(myFeature.$item_nav) .data('item', $item) .click(myFeature.showContentItem); &#125;); &#125;, 'showSection': function () &#123; // stays the same &#125;, 'showContentItem': function () &#123; // stays the same &#125;&#125;; 在myFeature.config中配置的默认参数，都可以在调用myFeature.init()时将其改写： 123$(document).ready(function() &#123; myFeature.init(&#123; 'itemNavSelector' : 'h2' &#125;);&#125;); 在本文所讨论的例子之外，另外一个值得考虑并且可以通过对象字面量模式实现的功能：使用jQuery history 插件实现「返回键」可以返回之前切换过的tab。这个练习留给读者去实现。 总结如果你一步步跟着例子做下来，那么应该对对象字面量模式有了一个基本的了解，知晓这个模式如何帮助开发更加复杂的应用。例子中的部分代码可以作为复杂应用的基础。 我鼓励你在下次发现自己写稍微复杂的代码时试试对象字面量模式，她强迫你对组成一个复杂应用的元素和行为进行思考。当你掌握次模式时，她将为你扩展和重用代码提供了坚实的基础。 更多 More on the jQuery data() method More praise for the object literal pattern The jQuery History plugin An interesting application of the object literal pattern for architecting code for multiple page types My presentation at the 2009 jQuery Conference about code organization]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[详解 JavaScript 中的 parseInt 函数]]></title>
      <url>%2F2013%2Fparseint-function-in-javascript%2F</url>
      <content type="text"><![CDATA[之前在 Stack Overflow 看到题目 `parseInt(1/0, 19)，代码执行的结果是 18，令人出乎意料。虽然这个题目是很少见到的情况（0作为被除数、采用19进制），但这个题目是一个很好的了解JavaScript parseInt 函数的机会。 要解答 parseInt(1/0, 19)这个题目，要理解两个知识点： 1/0 的值是什么？ parseInt 函数是怎么样将一个 String 转化成Int？ 0 作为被除数JavaScript里的所有算术运算采用的是IEEE 754 Standard。在 IEEE 754 Standard 中定义当被除数为 0 时，结果是（正/负）无穷大，无穷大在 JavaScript 中使用 Infinity 代表。所以表达式 1/0 的结果是正无穷大，即：Infinity。 parseInt函数parseInt的定义是：接收一个字符串并返回一个基于指定基数的整型值。语法为： 1parseInt(string, radix); parseInt 执行的步骤可以分为四个： 初步解析 string 参数 解析 radix 基数参数 根据 radix 再次解析字符串 返回结果 执行步骤说明如下： 初步解析字符串函数指定第一个参数是字符串，但存在着传入的参数是非字符串类型的可能性。所以这一步中，首先将 string 参数转换成 字符串类型。接着，剔除掉转换之后的字符串前面的空白符，生成新的字符串string1。若字符串为空，则返回NaN。 parseInt(1/0, 19) 中，1/0 表达式的值为 Infinity。Infinity 是一个数值，所以，在这一步将被转换成 &quot;Infinity。 接着，判断string1是否包含+或者-符号，设定sign变量为+/-，并将符号从字符串中剔除，生成字符串string2。这一步执行完毕之后，获取新的字符串 string2，没有包含空格以及+/-符号。 解析基数参数与string参数相同，radix可能非数值，所以首先将radix转换成整型radix1。在JavaScript中，radix的取值可能有两种：等价于0的值（比如undefined、null、false、””以及0本身），[2-36]。若radix1的取值不在这两者之中，返回NaN。这一步执行完毕，获取新的基数值 radix1。 再次解析字符串基数的范围设定在[2-36]，其中前十位使用[0-9]表示，[10-35]位使用英语字母表示，即[a-z]或者[A-Z]。从这里可以看出基数的大小决定着字符串的取值有效范围[0-9a-ZA-Z]。例如： parseInt(“a”, 10);// 在基数为10的情况下，”i”不能被转换成有效的数值，所以返回的是NaN parse(“a”, 11”);// 基数更改为11，”a”可以被转换成10由于基数会影响解析的行为，所以这里需要再次解析字符串。此时将逐个检查字符串中的字符，当遇到字符在基数指定的有效范围之外，解析停止，字符串中后续的字符将被丢弃，生成新的字符串string3。若string3为空，返回NaN。需要注意的是这一步中，基数有一个特殊的取值情况是： 当基数为16时，字符串中若开头为”0x”/“0X”，这两个字符将被过滤掉。因为16进制的表示法为“oxNN”。 这一步执行完毕之后，获取新的字符串 string3。 返回结果最后一步，将上一步中获取的string3转换成数值表示，如”a”在11进制中将被转换成10；然后将符号sign添加到数值上，并返回结果 再看 parseInt(1/0,19)从上面的执行步骤来看，parseInt(1/0, 19)即是parseInt(“Infinity”, 19)；在基数为19的情况下，字符串中第一个字符”I”是有效的数值，但第二个字符”n”无效，所以又变成了parseInt(“I”, 19)。”i”所对应的数值如下所示： 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18所以结果是：18 发散另外有一个道题目，将数组所有元素的字符串转换成整型值： 1["10", "10", "10", "10", "10"].map(parseInt) map 函数的语法为：[].map(fn)。 map 函数在数组的每个元素上执行fn，返回在每个元素上执行fn结果组成的数组。fn函数接收三个参数：元素值、元素索引值、数组本身。所以上面的调用执行的是： 1234567[ parseInt("10", 0); // 基数0, 即默认10进制 parseInt("10", 1); // 基数1无效，返回NaN parseInt("10", 2); // 基数2， 10表示2 parseInt("10", 3); // 基数3， 10表3 parseInt("10", 4); // 基数4， 10表示4] 所以，结果是：[10, NaN, 2, 3, 4]。 潜在的 Bug如果使用JSHint校验parseInt(1/0)的时候会提示： 12Line 2: parseInt(1/0);Missing radix parameter. 提示需要指定 radix（第二个参数）。举个例子： 1parseInt("08"); 8进制和16进制的数字以”0”开头（16进制是”0X”)，所以在有些脚本解释器中（IE8浏览器）可能误以8进制来解析”08”这个字符串。在8进制中，”08”是个无效的值，所以无法得到预期值。为了保证结果的准确性，建议在使用parseInt的时候，指明基数。 参考： ParseInt - MDN Annotated ECMAScript 5.1 # parseInt map - MDN IEEE 754 Standard]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QUnit快速上手]]></title>
      <url>%2F2013%2Fgetting-started-qunit%2F</url>
      <content type="text"><![CDATA[准备测试环境 在Qunit官网下载qunit.js和qunit.css两个文件，然后放进qunit文件夹； 创建test.html，内容为： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;QUnit Example&lt;/title&gt; &lt;link rel="stylesheet" href="qunit/qunit.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="qunit"&gt;&lt;/div&gt; &lt;div id="qunit-fixture"&gt;&lt;/div&gt; &lt;script src="qunit/qunit.js"&gt;&lt;/script&gt; &lt;!– 源文件 –&gt; &lt;!– 测试脚本 –&gt;&lt;/body&gt;&lt;/html&gt; QUnit 对源文件和测试脚本的存放目录结构没有任何要求，可以自由配置，只要在 tests.html（此文件名亦可自定义）正确引用 qunit.js、qunit.css、源文件和测试脚本文件即可。这里我采用如下的目录结构： 1234567891011.├── qunit│ ├── qunit-1.12.0.css│ └── qunit-1.12.0.js├── src│ ├── array.js│ └── core.js├── test│ ├── array-test.js│ └── core-test.js└── tests.html 我将源代码放置在 src 目录下（其中有两个文件：array.js 和 core.js），测试脚本放置在 test 目录中（与源码文件对应： array-test.js 和 core-test.js）。每一份源代码文件对应着一个测试脚本文件，在名称上，测试脚本文件文件名 = 源代码文件名 + “-test”。测试执行文件为：tests.html，qunit库的文件放置在qunit目录下。 编写源文件以及测试脚本文件 src/core.js，在 core.js 文件在定义了一个判断是否 object 是数组的方法： isArray()： 123function isArray(object) &#123; return Object.prototype.toString.call(object) === "[object Array]";&#125; 文件 test/core-test.js，src/core.js 对应的测试脚本： 123456test("Function: isArray", function() &#123; // 断言方法ok()，接收两个参数。 // 第一个参数是true即通过测试，第二参数为断言提示信息 ok(isArray([1, 2]), "[1, 2] is an array"); ok(!isArray(&#123;&#125;),"&#123;&#125; is NOT an array");&#125;); 文件 src/array.js，定义了 filter 函数。filter 函数遍历数组 array 中的元素，在各个元素上调用 fn，fn 执行返回 true 则将元素保存进新的数组，最后返回新的数组。 123456789function filter(array, fn) &#123; var result = []; for (var i = 0; i &lt; array.length; i++) &#123; if (fn.call(null, array[i])) &#123; result.push(array[i]); &#125; &#125; return result;&#125; 文件 test/array-test.js，src/array.js 对应的测试脚本： 123456789test("Function: filter", function() &#123; function greaterThan(value) &#123; return value &gt; 10; &#125; // 断言方法equal()，接收三个参数。 // 第一个参数为 运行结果，第二个参数为 期望值，第三个参数为断言提示信息。 equal(filter([9, 10, 11], greaterThan), [11], "11 is greater then 10");&#125;); 引用文件并执行测试修改 tests.html，引用需要测试的源文件以及对应的测试脚本文件： 1234567&lt;!– 源文件 –&gt;&lt;script src=”src/core.js”&gt;&lt;/script&gt;&lt;script src=”src/array.js”&gt;&lt;/script&gt;&lt;!– 测试脚本 –&gt;&lt;script src=”test/core-test.js”&gt;&lt;/script&gt;&lt;script src=”test/array-test.js”&gt;&lt;/script&gt; 在浏览器中打开tests.html，即可执行测试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SimpleDateFormat 一小时之谜]]></title>
      <url>%2F2013%2Fsimpledataformat%2F</url>
      <content type="text"><![CDATA[背景介绍近期，编写了一个针对JavaScript日期格式化类的测试。这个JavaScript日期格式化类模仿Java中的SimpleDateFormat类（java.text.SimpleDateFormat）的格式。测试采用QUnit作为JavaScript单元测试工具。结合QUnit，同时需要SimpleDateFormat类的格式输出结果做比对，那么最为简便的测试环境是使用JSP（容器/服务器可选择Tomcat），测试的步骤如下： 定义格式化模式（Pattern），这个模式同时需要在 JSP页面 和 测试脚本中定义。比如：”HH:mm:ss”； 在JSP页面中，使用SimpleDateFormat类格式化日期，并将日期原始数据和格式化结果写在页面上。例如：&lt;div class=”date”&gt;&lt;%= date.getTime()%&gt;&lt;/div&gt;&lt;div class=”result”&gt;&lt;%= formatter.format(date)%&gt;&lt;/div&gt; 在测试脚本中，获取页面上的日期原始数据并进行格式化；将结果与(2)中输出的结果进行比对。测试分为“模式（Pattern）”测试，“本地化（Locale）”测试，“边界值（Boundary）”测试以及“随机（Random）”测试。其中： 模式测试，是指针对单个模式（如”y”, “yy”, “yyyy”）进行测试。模式字母个数的不同，输出的结果也不同，如假定年份是2013，那么模式”y”和”yy”输出是13，而”yyyy”输出则是2013。 本地化测试，是指针对时区进行测试，在国际化的场景中比较实用。比如测试（GMT 0）以及本地时区（GMT +8）的数据相差值是否正确。 边界值测试，是指针对边界情况进行测试。比如，当选择2月份，并错误的将天数设定为30天，此时应该可以向前推算，变成3月1号/3月2号。 随机测试，是指随机生成样例进行大范围的测试。“一小时”之谜假定 JavaScript 日期格式化类定义在Example.Date，格式方法为format。在进行随机测试的过程（随机生成100样例）中，发现会有一定的个数出现失败。// 随机测试的JSP代码SimpleDateFormat sdfRandom = new SimpleDateFormat(“yyyy-MM-dd HH:mm E a h”);Random rand = new Random();for (int i = 0; i &lt; 100; i++) { int year = 1970 + rand.nextInt(2014 - 1970); int month = rand.nextInt(12); int day = rand.nextInt(32); int hour = rand.nextInt(24); int minute = rand.nextInt(60); int second = rand.nextInt(60); cal.set(year, month, day, hour,minute, second); date = cal.getTime(); // 输出结果到页面} // 测试脚本代码test(“random”, function() { var date = null; var result = null; var jsFormatter = Example.Date.format; var jsResult = null; var lengthOfTestcase = document.querySelectorAll(“.random-test-case”).length; for (var i = 0; i &lt; lengthOfTestcase; i++) { date = document.getElementById(“random-“ + i + “-date”).innerHTML; result = document.getElementById(“random-“ + i + “-result”).innerHTML; jsResult = jsFormatter(“yyyy-MM-dd HH:mm E a h”, date); equal(jsResult, result, “The format should be:” + result); }});所有失败样例的特点都一致，即SimpleDateFormat输出的结果比Example.Date.format输出的结果在“小时”上刚刚好多一个小时：Expected: “1986-09-03 06:06 Wed AM 6”Result: “1986-09-03 05:06 Wed AM 5”Diff: “1986-09-03 06:06 05:06 Wed AM 6” 5”定位问题 经过一番排查之后，最终发现最大的可疑点。例如：Unix时间戳526079183在SimpleDateFormat输出与在JavaScript中输出结果不一致：// JavaScriptconsole.log(new Date(526079183*1000));// Wed Sep 03 1986 05:06:23 GMT+0800 (China Standard Time)// Java SimpleDateFormatformatter.format(526079183000L);// 1986-09-03 06:06:23用其他语言进行佐证，比如采用Ruby：# Ruby irbTime.at(526079183)# =&gt; 1986-09-03 05:06:23 +0800可以看到JavaScript的输出与Ruby的输出一致，那么原因在于SimpleDateFormat上。问题的可能原因在于SimpleDateFormat中会涉及到夏令时（Daylight saving time）。Wikipedia上关于夏令时的定义：夏时制，又称日光节约时制、日光節約時間（英语：Daylight saving time）或夏令时间（英语：Summer time），是一种为节约能源而人为规定地方时间的制度，在这一制度实行期间所采用的统一时间称为“夏令时间”。一般在天亮早的夏季人为将时间提前一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。各个采纳夏时制的國家具体规定不同。目前全世界有近110个国家每年要实行夏令时。其中，中国在1986年至1991年之间实行过夏令时。 验证猜想 可以从两点上进行判断是否是由于夏令时导致： 设置SimpleDateFormat的时区为GMT 0以避免夏令时。SimpleDateFormat sdfRandom = new SimpleDateFormat(“yyyy-MM-dd HH:mm E a h”);sdfRandom.setTimeZone(TimeZone.getTimeZone(“UTC”));Random rand = new Random();… 将随机的样例数据范围设定在实行夏令时的时间段内，那么失败样例的比例应该会大幅提高。…int year = 1986 + rand.nextInt(1991 - 1986);…结果数据上验证了猜想。在采用夏令时的时间上，SimpleDateFormate输出的结果将多出一个小时，即提前了一个小时。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM基础之Node Objects]]></title>
      <url>%2F2013%2Fdom-foundation-node-objects%2F</url>
      <content type="text"><![CDATA[文档对象模型（DOM） DOM全称Document Object Model，由浏览器实现的一套编程接口，以便动态更改文档（通过JavaScript）。DOM是一棵树，在浏览器解析HTML页面的时候生成，这棵树由JavaScript节点对象（Node Objects）组成。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;DOM Tree&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;p&gt;DOM Demo&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 上面的代码将生成如下的DOM： ■ DOCTYPE(9) ↓ ■ HTML(1) ↙ ↙ ↘ ↘ ■ #text(3) ■ HEAD(1) ■ BODY(1) ■ #text(3) ↓ ↙ ↓ ↘ ■ TITLE(1) ■ 回车换行(3) ■ P(1) ■ 回车换行(3) ↓ ↓ ■ #text(3) #text(3) 括号中的数字代表节点类别：1代表元素节点、3代表文本节点、10代表文档类型节点 节点对象（Node Objects） DOM树由节点对象组成，节点对象根据类型的不同又分为许多类别，但都派生于Node。Node类是一个JavaScript构造函数，继承Object，拥有节点的通用属性和方法。节点对象的继承关系例子： 元素节点对象A HTMLAnchorElement &lt; HTML *Element &lt; HTML Element &lt; Element &lt; Node &lt; Object 文本节点 Text &lt; CharacterData &lt; Node &lt; Object 文档节点 HTMLDocument &lt; Document &lt; Node &lt; Object 文档片段节点 DocumentFragment &lt; Node &lt; Object 根据节点的不同，节点对象分为许多类别，这些类别都有自己的构造函数。常见的节点类别有： ELEMENT_NODE 元素节点，比如DIV TEXT_NODE 文本节点，比如普通文字也包括回车换行符、空白符 DOCUMENT_NODE 文档节点，比如window.document DOCUMENT_TYPE_NODE 文档类型节点，比如 DOCUMENT_FRAGMENT_NODE 文档片段节点，比如通过document.createDocumentFragment()创建的节点 节点对象的类别信息以键值对形式作为静态属性存储于Node构造函数中。可以通过以下的代码查看所有的节点类别信息： for (var p in Node) { console.log(p, " = " + Node[p]); } 输出的结果片段： ELEMENT_NODE = 1 ATTRIBUTE_NODE = 2 TEXT_NODE = 3 ... 从输出的结果中可以看出每种类别对应一个数字的值，在判断节点类别的时候，通常使用这个数字值进行判断，例如： var ul = document.getElementById("ul"); console.log(ul.nodeType === Node.ELEMENT_NODE); // true console.log(ul.nodeType === 1); // true 节点对象的属性与方法 Node构造函数定义了节点通用的属性和方法。 Node实例属性列表： childNodes firstChild lastChild previousSibling nextSibling parentNode nodeName nodeType nodeValue常用的Node实例方法： appendChild() insertBefone() cloneNode() removeChild() replaceChild() 特定的节点类别继承了Node的属性和方法，同时还有拥有特定的方法： 例如，DOCUMENT_NODE拥有方法document.createElement()和document.createTextNode()方法。 HTML *ELMENT节点拥有以下常见的属性： innerHTML outerHTML innerText outText children]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Expose shuffle function of underscore.js]]></title>
      <url>%2F2013%2Fexpose-shuffle-function-of-underscore%2F</url>
      <content type="text"><![CDATA[underscore.js 里有一个数组重新随机排序的函数 _.shuffle： 12345678910111213// Shuffle an array._.shuffle = function (obj) &#123; var rand; var index = 0; var shuffled = []; each(obj, function (value) &#123; // _.random函数返回[0, index]之间的随机数 rand = _.random(index++); shuffled[index - 1] = shuffled[rand]; shuffled[rand] = value; &#125;); return shuffled;&#125;; 函数的算法 创建 数组 shuffled = []，用于保存随机排序后的数组； 迭代 待排序数组，设定当前迭代索引 index = 0； 生成 随机索引 rand。rand 的值介于 [0, index]； 添加 元素到 shuffled 数组，值为 shuffled[rand]； 赋予 shuffle[rand] 当前迭代元素的值 运行过程假定现有待随机排序数组 array = [1, 2, 3, 4, 5]，那么第一次迭代的时候情形如下： 123456789array[index]: 1, index: 0, rand: 0, shuffled: [] rand ↓ ■ □ □ □ □ ↑ index shuffled = [1]; 此时，rand 的值只能与 index 的值相等，所以 shuffled 第一个元素取值为待排序数组的第一个元素。 第二次迭代时，假定 rand 随机值为 0（ rand 的值只能在 [0, index] 之间）： 123456789array[index]: 2, index: 1, rand: 0, shuffled: [1] rand(assume) ↓ ■ ■ □ □ □ ↑ index shuffled = [2, 1]; shuffle[1] 被赋值为 shuffle[0]，shuffle[0] 被赋值为 array[1]。 最后一次迭代假设此时 rand = 1，shuffled = [2, 4, 1, 5]： 12345678array[index]: 3, index: 4, rand: 1, shuffled: [2, 4, 1, 5] rand(assume) ↓ ■ ■ ■ ■ ■ ↑ indexshuffle = [2, 3, 1, 5, 4] shuffled[4] 将会被赋值为 shuffled[1]，shuffled[1] 被赋值为 3。所以 shuffled 最后为 [2, 3, 1, 5, 4]。 另一种思路 迭代 待排序数组； 生成 随机索引 rand，索引的范围为 [0 ~ 待排序数组 - 1]； 抽取 待排序数组中索引为 rand 的元素，抽取行为改变了待排序数组； 追加 抽取的元素到结果数组的末尾 123456789101112131415161718function shuffle(array) &#123; var rand; var shuffled = []; for (var i = 0, l = array.length; i &lt; l; i++) &#123; // 获取随机索引值。 // 随机索引值的范围为[0 ~ 原始数组的长度 - 1] rand = random(array.length - 1); // 使用splice方法抽取数组元素 shuffled[i] = array.splice(rand, 1)[0]; &#125; return shuffled;&#125;function random(min, max) &#123; (Object.prototype.toString.call(max) !== "[object Number]") &amp;&amp; (max = min); return min + Math.floor(Math.random() * (max - min + 1));&#125; 相对于 _.shuffle，这个方法每个元素在每次迭代过程中就确定下来了，而 _.shuffle 结果数组中每个元素在最后一步完成前都可能改变。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的单例模式（Singleton Pattern ）]]></title>
      <url>%2F2013%2Fsingleton-pattern-in-javascript%2F</url>
      <content type="text"><![CDATA[单例（Singleton）的定义: The idea of the singleton pattern is to have only one instance of a specific class. This means that the second time you use the same class to create a new object, you should get the same object that was create the first time.单例模式是指在程序中一种特殊的类（class），他们仅有一个实例。这意味着当这个类在被第一次实例化后，之后的实例化操作都将获得到第一次实例化时产生的实例。 对象字面量与单例以对象字面量(Object Literal)定义的对象本身即为单例： 12345678910111213141516var o1 = &#123; name: "SP1 Object Literal", getName: function() &#123; return this.name; &#125;&#125;;var o2 = &#123; name: "SP1 Object Literal", getName: function() &#123; return this.name; &#125;&#125;;// o2的键值与o1完全相同，但他们是不同的对象。console.log(o1 === o2); // false 对象字面量实现单例模式的另外一种形式： 12345678910var o = (function()&#123; var name = "SP2 IIFE Method"; var getName = function() &#123; return this.name; &#125;; return &#123; name: name, getName: getName &#125;;&#125;()); 构造函数与单例通过 new 操作符调用构造函数创建对象的方式中，实现单例模式的关键点在于： 第一次调用构造函数时，存储创建的实例 后续的调用，直接返回实例 依据这个思路，有三种实现方式。 第一种最为简单，但也是最不可靠的方式：将实例存储在全局变量中。 12345678910111213// 存储实例的全局变量。因为这个全局变量可能被改写，所以此方法不可靠。var o = null;function SingletonPattern3() &#123; if (o) &#123; return o; &#125; this.name = "SP3"; o = this;&#125;var s1 = new SingletonPattern3();var s2 = new SingletonPattern3();console.log(s1 === s2); // true 第二种方法，将实例存储在构造函数的静态属性中。相对第一种方式，此方式显然会比较安全一些，但此构造函数的静态属性仍然存在被修改的可能性。 123456789101112131415161718function SingletonPattern4() &#123; // 保存构造函数的引用 var constructor = arguments.callee; if (constructor.instance) &#123; return constructor.instance; &#125; this.name = "SP4"; // 将实例存储于构造函数的静态属性instance中 constructor.instance = this;&#125;SingletonPattern4.prototype.getName = function() &#123; return this.name;&#125;;var s1 = new SingletonPattern4();var s2 = new SingletonPattern4();console.log(s1 === s2); // true 第三种方式，采用闭包。第一次调用之后，存储实例，并改写构造函数自身。 1234567891011121314151617function SingletonPattern5() &#123; var sp = this; this.name = "SP5"; // 改写构造函数 SingletonPattern5 = function() &#123; return sp; &#125;;&#125;SingletonPattern5.prototype.getName = function() &#123; return this.name;&#125;;var s1 = new SingletonPattern5();var s2 = new SingletonPattern5();console.log(s1 === s2); // true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Prevent VMWare WorkStation guest machines from sysning time with host]]></title>
      <url>%2F2013%2Fprevent-vmware-workstation-guest-machines-from-sysning-time-with-host%2F</url>
      <content type="text"><![CDATA[Navigate to the directory where the virtual machine stored. Open %virtual machine name%.vmx file with your favourite editor. Search Text: “tools.syncTime”. Add the following text under the result line: time.synchronize.continue = &quot;FALSE&quot; time.synchronize.restore = &quot;FALSE&quot; time.synchronize.resume.disk = &quot;FALSE&quot; time.synchronize.shrink = &quot;FALSE&quot; time.synchronize.tools.startup = &quot;FALSE&quot; time.synchronize.tools.enable = &quot;FALSE&quot; time.synchronize.resume.host = &quot;FALSE&quot; 5.Restart the guest to check the result.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavasScript 语言的 void 操作符]]></title>
      <url>%2F2013%2Fvoid-operator-in-javascript%2F</url>
      <content type="text"><![CDATA[JavaScript 中的 void 操作符语法如： 1void expression void 执行 expression 并返回 undefined。 void 常见的两个用途是： 获取 undefined 变量 作为 href 的伪协议 在 JavaScript中 undefined 并不是一个保留字，所以存在着被更改的可能，这也意味着直接通过判断给定的变量是否 undefined 并非可靠。所以此时可以通过 void 来判断变量是否是 undefined： 1234// underscore 中的 isUndefined 函数_.isUndefined = function (obj) &#123; return obj === void 0;&#125;; 第二种用途中，作为 html 中 href 的 JavaScript 伪协议值。这个值将阻止页面进行跳转。 1&lt;a href="javascript:void(0);"&gt;空链接&lt;/a&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Google通过Code School提供免费Web开发教程]]></title>
      <url>%2F2013%2Ffree-web-course-from-code-school%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript数组队尾添加元素的方法]]></title>
      <url>%2F2013%2Fadd-items-to-array-in-javascript%2F</url>
      <content type="text"><![CDATA[往数组末尾添加元素的方式通常是采用数组的 push 方法，如： 123var array = [1, 2, 3];array.push(4);console.log(array); // [1, 2, 3, 4] 在 underscore.js 中采用的另一种小技巧： 12var array = [1, 2, 3];array[array.length] = 4; JavaScript 数组是从 0 开始索引，所以数组中最后一个元素的索引值就是 数组的长度 - 1。往数组末尾添加元素可对 数组最后一个元素 + 1 索引的位置进行赋值，也就是对 array[array.length] 进行赋值。 需要注意的是，在循环往数组中添加元素的时候应采用 array.length，而非将 array.length 存储在局部变量中： 12345678910// 循环添加元素时，将array.length存储在变量(len)中// 并通过array(len)添加元素时将出现非预期的行为var array = [1, 2, 3];var l = array.length;for (var i = 0; i &lt;= l; i++) &#123; array[l] = i;&#125;console.log(array); // [1, 2, 3, 3] 我们的预期结果是 [1, 2, 3, 0, 1, 2, 3]： 12345678var array = [1, 2, 3];var l = array.length;for (var i = 0; i &lt;= l; i++) &#123; array[array.length] = i;&#125;console.log(array); // [1, 2, 3, 0, 1, 2, 3]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[犀牛书中关于闭包的定义]]></title>
      <url>%2F2013%2Fclosure-definition-in-javascript-definitive-guide%2F</url>
      <content type="text"><![CDATA[Javascript函数是将要执行的代码以及执行这些代码的作用域构成的一个综合体。在计算机科学术语里，这种代码和作用域的综合体叫做闭包。所有的Javascript函数都是闭包。在上面讨论的那种情况，也就是说，当一个嵌套函数被导出到它所定义的作用域外时，这种闭包才是有趣的。当一个嵌套的函数以这种方式使用的时候，它常常明确的叫做一个闭包。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[循环里的setTimeout]]></title>
      <url>%2F2013%2Floops-in-settimeout%2F</url>
      <content type="text"><![CDATA[setTimeout函数的定义 Calls a function or executes a code snippet after a specified delay.在指定的延迟后，执行代码/函数 setTimeout 函数接收两个参数，语法为： 1timeoutID = setTimeout(func, delay); 第一个是将要执行的代码片段或者函数，第二个参数是延迟时间，单位是毫秒。例如，在5s后弹出提示： 123setTimeout(function() &#123; alert("Times over");&#125;, 5000); 循环中的 setTimeout12345for (var i = 0; i &lt;= 3; i++) &#123; setTimeout(function logger() &#123; console.log(i); &#125;, 0);&#125; 循环中，在 0ms 后调用 logger 函数输出 i 的值。那么结果应该是：0 1 2 3？ 但实际代码的输出是： 14 4 4 4 了解 setTimeout1234567var start = new Date;setTimeout(function logger()&#123; var end = new Date; console.log('Time elapsed:', end - start, 'ms');&#125;, 500);while (new Date - start &lt; 1000) &#123;&#125;; 执行代码片段后可以发现代码输出 Time elapsed: 10XXms。也就是说，logger函数事实上是在while 后执行的。 在 JavaScript 中，setTimeout 所传入的函数在线程空闲之前不会调用。在线程空闲后，并且满足 setTimeout 所设定的 delay 值后，函数才会被调用。在上面的代码中，logger函数 只有在 for 循环结束后才会被调用；而 for 循环结束时，i 的值为 4，故程序的输出为 4 4 4 4。 setTimeout 中函数的 this123456789101112function setTimeoutTest() &#123; this.name = "Test function"; console.log(this); for (var i = 0; i &lt;= 3; i++) &#123; setTimeout(function logger() &#123; console.log(i); console.log(this); &#125;, 0); &#125;&#125;new setTimeoutTest(); 上面的代码在控制台上输出两个变量：this 和 i。 可以发现前后 this 的指向是不同的。在使用 new setTimeoutTest 之后，在 setTimeoutTest 内部 this 的值指向 setTimeoutTest 的一个实例，故第一个 this 指向 {name: &quot;Test function&quot;}； logger函数 定义在 setTimeoutTest 函数内部，所以 logger函数 作用域链上保存着 i 以及 this 的值，而 logger函数是在全局作用域下调用的，此时作用域链上i的值依然是 4，但是 this 的值指向了 window。所以函数最终的输出为： 1234&#123;name: "Test function"&#125;4 window4 window4 window 参考资料： window.setTimeout - MDN]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bootstrap themes]]></title>
      <url>%2F2013%2Fbootstrap-themes%2F</url>
      <content type="text"><![CDATA[Bootswatch (免费) WrapBootstrap (主题商城) BootstrapThemeRoller (定制)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Learning Ruby with the Neo Ruby koans]]></title>
      <url>%2F2013%2Flearing-ruby-with-the-neo-ruby-koans%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[MacOSX Mountain Lion下使用rvm安装ruby 1.9.3]]></title>
      <url>%2F2013%2Finstall-ruby-via-rvm-on-mac-osx%2F</url>
      <content type="text"><![CDATA[在MacOSX Mountain Lion with XCode 4.5.2/4.6下使用rvm安装ruby 1.9.3会出现compile错误： Error running ‘make’, please read /Users/ivan/.rvm/log/ruby-1.9.3-p374/make.logThere has been an error while running make. Halting the installation. make.log中的错误信息： compiling regparse.c regparse.c:582:15: error: implicit conversion loses integer precision: &apos;st_index_t&apos; (aka &apos;unsigned long&apos;) to &apos;int&apos; [-Werror,-Wshorten-64-to-32] return t-&gt;num_entries;&lt;/blockquote&gt; 解决方法： rvm install 1.9.3 --with-gcc=gcc 参考资料 ： XCode 4.6 break rvm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery Mockjax]]></title>
      <url>%2F2013%2Fjquery-mockjax%2F</url>
      <content type="text"><![CDATA[jQuery Mockjax用于模拟Ajax请求数据，以解决Server API未就绪时的前端开发阻塞问题。 假设前端发起一个/test/inline API的请求： $.ajax({ url: &apos;/test/inline&apos;, dataType: &apos;json&apos;, success: function(json) { alert(&apos;You said: &apos; + json.say); } }); 假若API同时在开发当中，此时可以使用jQuery Mockjax来模拟API： $.mockjax({ url: &apos;/test/inline&apos;, dataType: &apos;json&apos;, responseTime: 2500, responseText: { say: &apos;Hello world!&apos; } }); 项目地址： jQuery.mockjax]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NPM package.json里的注释]]></title>
      <url>%2F2013%2Fcomments-in-package-json%2F</url>
      <content type="text"><![CDATA[使用//作为键值即可： { &quot;//&quot;: &quot;comment&quot; } 多行注释有两种写法： &quot;//&quot;: &quot;第一种&quot;, &quot;//&quot;: &quot;something more&quot; &quot;//&quot;: &quot;第二种&quot; &quot;//&quot;: [&quot;comment&quot;, &quot;something more&quot;] 完整示例： { &quot;name&quot;: &quot;CountDown&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;//&quot;: &quot;All dependencies MUST be Compatible with Grunt 0.4&quot;, &quot;devDependencies&quot;: { &quot;grunt&quot;: &quot;~0.4.0&quot;, &quot;grunt-contrib-jshint&quot;: &quot;~0.1.1&quot;, &quot;grunt-contrib-jasmine&quot;: &quot;~0.3.0&quot;, &quot;grunt-contrib-uglify&quot;: &quot;~0.1.1&quot; } } 参考资料： How do I add comments to package.json for npm install? - StackOverflow Node.js mailing list]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何删除 Github 上的项目的某一个 commit?]]></title>
      <url>%2F2013%2Fdelete-specific-commit-git%2F</url>
      <content type="text"><![CDATA[如果不小心将账户密码或者私钥信息提交到了 Github 上，应该怎么删除那个提交呢？需要以下步骤： 首先，在本地仓库中移除这个提交，可以使用 git rebase -i 命令。如果带有重要信息的提交是最后一个提交，那么可以使用： 1git rebase -i HEAD~2 删除掉对应的提交后保存退出。 强制更新 Github上 的分支，有两种方法： 12git push origin +master # 方法一，使用+强制更新git push -f origin HEAD^:master # 方法二，使用-f参数 参考： How do remove a commit on Github?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Grunt]]></title>
      <url>%2F2013%2Fgrunt%2F</url>
      <content type="text"><![CDATA[Grunt is a task-based command line build tool for JavaScript projectsProject @ Github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Break $.each loop]]></title>
      <url>%2F2013%2Fbreak-jquery-each-loop%2F</url>
      <content type="text"><![CDATA[結束 jQuery.each 的循環是通過設定 jQuery.each 的 callback 函數中返回 false；而繼續下一個循環（即 continue ），是 return 非 false 值。亦適用於 .each。 1234567891011121314151617(function()&#123; // 結束循環（即break） jQuery.each(aOptionList, function(index, option)&#123; if (option.innerHTML === "stop") &#123; return false; // 返回false即break掉each循環 &#125; // magic &#125;); // 繼續下一個循環（即continue） jQuery.each(aOptionList, function(index, option)&#123; if (option.innerHTML === "stop") &#123; return "continue"; // 返回任意非false值 &#125; // magic &#125;);&#125;()); 官方說明： We can break the $.each() loop at a particular iteration by making the callback function return false. Returning non-false is the same as a continue statement in a for loop; it will skip immediately to the next iteration. 参考资料： jQuery.each API]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Everything you always wanted to know about touch icons]]></title>
      <url>%2F2012%2Feverything-you-always-wanted-to-know-about-touch-icons%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718&lt;!-- For third-generation iPad with high-resolution Retina display: --&gt;&lt;link rel="apple-touch-icon-precomposed" sizes="144x144" href="apple-touch-icon-144x144-precomposed.png"&gt;&lt;!-- For iPhone with high-resolution Retina display: --&gt;&lt;link rel="apple-touch-icon-precomposed" sizes="114x114" href="apple-touch-icon-114x114-precomposed.png"&gt;&lt;!-- For first- and second-generation iPad: --&gt;&lt;link rel="apple-touch-icon-precomposed" sizes="72x72" href="apple-touch-icon-72x72-precomposed.png"&gt;&lt;!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: --&gt;&lt;link rel="apple-touch-icon-precomposed" href="apple-touch-icon-precomposed.png"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Compass]]></title>
      <url>%2F2012%2Fcompass%2F</url>
      <content type="text"><![CDATA[Compass is an open-source CSS Authoring Framework. Compass uses Sass.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[避免调用 console 相关方法在 IE6/7 等不支持的浏览器下报错]]></title>
      <url>%2F2012%2Fconsole-function-in-ie6-7%2F</url>
      <content type="text"><![CDATA[来自 HTML Boilerplate 前端框架的方法。 原理很简单： 判断 console 对象是否存在，不存在则新建： 1var console = (window.console = window.console || &#123;&#125;); 定义包含 console 对象方法名称的数组。迭代数组，判断 console 对象是否具有对应的方法，如果方法不存在，在 console 对象上新建此方法，并赋值空函数。 123if (!console[method]) &#123; console[method] = function() &#123;&#125;;&#125;; 完整的代码： 12345678910111213141516171819202122232425262728// Avoid `console` errors in browsers that lack a console.(function() &#123; var method; // 空函数 var noop = function noop() &#123;&#125;; // 预测console方法列表 var methods = [ 'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn' ]; var length = methods.length; var console = (window.console = window.console || &#123;&#125;); while (length--) &#123; method = methods[length]; // 如果console的此属性（方法）不存在，则将其设定为空函数 if (!console[method]) &#123; console[method] = noop; &#125; &#125;&#125;());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Using delegate with hover in jQuery]]></title>
      <url>%2F2012%2Fusing-delegate-with-hover-in-jquery%2F</url>
      <content type="text"><![CDATA[1234567$("#myList").delegate("li", "hover", function ( event ) &#123; if (event.type == 'mouseenter') &#123; showButtons(); &#125; else &#123; hideButtons(); &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mateor]]></title>
      <url>%2F2012%2Fmateor%2F</url>
      <content type="text"><![CDATA[Meteor is an ultra-simple environment for building modern web applications. With Meteor you write apps: in pure Javascript that send data over the wire, rather than HTML using your choice of popular open-source libraries]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PhantomJS]]></title>
      <url>%2F2012%2Fphantomjs%2F</url>
      <content type="text"><![CDATA[PhantomJS is a headless WebKit with JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG.PhantomJS is created by Ariya Hidayat.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello, Java!]]></title>
      <url>%2F2012%2Fhello-java%2F</url>
      <content type="text"><![CDATA[Java 语言的 Hello World 代码： 12345public class HelloJava&#123; public static void main(String[] args)&#123; System.out.println("Hello, Java!"); &#125;&#125; 执行 Java 代码: 12$ javac HelloJava.java$ java HelloJava]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP Cookies: What's the difference between Max-age and Expires?]]></title>
      <url>%2F2012%2Fhttp-cookies-what-s-the-difference-between-max-age-and-expires%2F</url>
      <content type="text"><![CDATA[Quick Answer Expires sets an expiry date for when a cookie gets deleted Max-age sets the time in seconds for when a cookie will be deleted Internet Explorer (ie6, ie7, and ie8) does not support “max-age”, while (mostly) all browsers support expires]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IE浏览器对样式的限制]]></title>
      <url>%2F2012%2Flimitations-of-ie-browsers%2F</url>
      <content type="text"><![CDATA[Internet Explorer对样式的个数存在着限制，这些限制规则影响到IE 9及以下版本。同时，当触发限制时，IE会将超过限制的样式直接丢弃，不会给出任何提示。这些规则是： 一个页面限制STYLE（含REL为STYLESHEET的LINK）的个数不超过31个；包括一份Stylesheet @import的样式条数不超过31条 一份Stylesheet里面的规则的条数不超过4095条 @import不能超过4层嵌套 因为这个限制导致的BUG整整花费了一天的时间才查询到，最后发现问题页面比正常页面多出了很多写在BODY内的STYLE，才联想到了关于IE对STYLE是否有限制。 这个BUG常发生于页面输出用户经过编辑器编辑的文章（这次的BUG就是在页面已经包含超过31个或者更多的样式后再通过动态添加进去的Style失效。 微软官方相关的文档里面谈到关于IE 10对于Style的限制有两种修正方案： 增加限制的条数 完全去除这种限制 参考资料： A webpage that uses CSS styles does not render correctly in Internet Explorer]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Uninstall MySQL in MacOSX]]></title>
      <url>%2F2012%2Funinstall-mysql-in-macosx%2F</url>
      <content type="text"><![CDATA[准备工作 备份数据 停止MySQL Server 卸载开始123456789101112sudo vim /etc/hostconfig (remove the line MYSQLCOM=-YES-)sudo rm /usr/local/mysqlsudo rm -rf /usr/local/mysql*sudo rm -rf /Library/StartupItems/MySQLCOMsudo rm -rf /Library/PreferencePanes/My*sudo rm -rf /Library/Receipts/mysql*sudo rm -rf /Library/Receipts/MySQL*# 如果需要安装旧版本，必须执行这句sudo rm -rf /private/var/db/receipts/*mysql*sudo rm /etc/my.cnf]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sleep function in batch]]></title>
      <url>%2F2012%2Fsleep-function-in-batch%2F</url>
      <content type="text"><![CDATA[通用：1ping 127.0.0.1 -n 5 -w 1000 -n 1 only attempt to connect once. -w 3000 wait 3 seconds for reply. Windows Server 2003 / Windows Vista 以上1timeout /T 5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Image resize in JavaScript]]></title>
      <url>%2F2012%2Fimage-resize-in-javascript%2F</url>
      <content type="text"><![CDATA[设置图片组的 src 为自定义属性 data-img-src 的值 12345678910111213//注意for循环里的闭包for(var i = 0; i &lt; images.length; i++)&#123; (function(im)&#123; var img = new Image(); img.onload = function()&#123; im.src = img.src; self.imgResize(im, img.width, img.height, 75, 75); img.onload = null; &#125; img.onerror = function()&#123;&#125; img.src = im.getAttribute("data-img-src"); &#125;)(images[i]);&#125; jQuery 版本： 1234567891011121314151617images.each(function()&#123; if( this.src.indexOf('loading.gif') != -1)&#123; var im = new Image(); var img = this; im.onload = function()&#123; img.src = im.src; self.imgResize(img, im.width, im.height, 75, 75); im.onload = null; &#125; im.onerror = function()&#123; this.style.width = '75px'; this.style.height = '75px'; im.onerror = null; &#125; im.src = this.getAttribute('data-img-src'); &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见浏览器扩展的 MIME]]></title>
      <url>%2F2012%2Fmimes%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324&lt;mime-mapping&gt; &lt;extension&gt;crx&lt;/extension&gt; &lt;mime-type&gt;application/x-chrome-extension&lt;/mime-type&gt;&lt;/mime-mapping&gt;&lt;mime-mapping&gt; &lt;extension&gt;sext&lt;/extension&gt; &lt;mime-type&gt;application/x-sogou-extension&lt;/mime-type&gt;&lt;/mime-mapping&gt;&lt;mime-mapping&gt; &lt;extension&gt;xpi&lt;/extension&gt; &lt;mime-type&gt;application/x-xpinstall&lt;/mime-type&gt;&lt;/mime-mapping&gt;&lt;mime-mapping&gt; &lt;extension&gt;oex&lt;/extension&gt; &lt;mime-type&gt;application/x-opera-extension&lt;/mime-type&gt;&lt;/mime-mapping&gt;&lt;mime-mapping&gt; &lt;extension&gt;safariextz&lt;/extension&gt; &lt;mime-type&gt;application/octet-stream&lt;/mime-type&gt;&lt;/mime-mapping&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[访问 iframe 的 window/document 对象]]></title>
      <url>%2F2012%2Faccess-window-document-in-a-iframe%2F</url>
      <content type="text"><![CDATA[iframe 与宿主页面之间的通讯受 同源策略 影响。 访问 window 对象： 1var iframeWindow = iframe.contentWindow; 访问 document 对象： 12// IE8以上及标准浏览器通过contentDocument引用，IE8之前的IE使用iframe.documentvar iframeDocument = iframe.contentDocument || iframe.document;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[parseInt(1/0, 19)=18]]></title>
      <url>%2F2012%2Fparseint-1-0-19-18%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Equality comparison in ECMAScript 262 3rd edition]]></title>
      <url>%2F2012%2Fequality-comparison-in-ecmascript-262-3r-edition%2F</url>
      <content type="text"><![CDATA[问题： 12![] == []; // true"0" == 0 // true 运算法则： The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows: If Type(x) is different from Type(y), go to step 14. If Type(x) is Undefined, return true. If Type(x) is Null, return true. If Type(x) is not Number, go to step 11. If x is NaN, return false. If y is NaN, return false. If x is the same number value as y, return true. If x is +0 and y is −0, return true. If x is −0 and y is +0, return true. Return false. If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return false. If Type(x) is Boolean, return true if x and y are both true or both false. Otherwise, return false. Return true if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return false. If x is null and y is undefined, return true. If x is undefined and y is null, return true. If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y). If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y. If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y. If Type(y) is Boolean, return the result of the comparison x == ToNumber(y). If Type(x) is either String or Number and Type(y) is Object, return the result of the comparison x == ToPrimitive(y). If Type(x) is Object and Type(y) is either String or Number, return the result of the comparison ToPrimitive(x) == y. Return false.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Prototype based programming]]></title>
      <url>%2F2012%2Fprototype-based-programming%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[避免重写原型时constructor属性的指向错误]]></title>
      <url>%2F2012%2Fensure-construct-property-when-rewrite-prototype-in-javascript%2F</url>
      <content type="text"><![CDATA[在整个替换构造函数的prototype值时，会发生对象的constructor属性执行了Object，而非构造函数。通常的修正方法有以下两种： 1234567891011var Foo = function()&#123;&#125;;Foo.prototype = &#123; name : "foo", bar : function()&#123; console.log(this.name); &#125;&#125;;// 修正替换Foo.prototype后导致construtor指向错误Foo.prototype.constructor = Foo; 或者使用一个闭包的方式，局部更新prototype： 123456(function(p)&#123; p.name = "foo"; p.bar = function()&#123; console.log(p.name); &#125;&#125;)(Foo.prototype);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Get a github repository as a zip file via cURL]]></title>
      <url>%2F2012%2Fget-a-github-repository-as-a-zip-file-via-curl%2F</url>
      <content type="text"><![CDATA[1curl -Lk https://github.com/someone/likeyou/zipball/master &gt; likeyou-latest.zip cURL manual]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从参数看 JavaScript 字符串的 slice、substring 以及 substr 函数]]></title>
      <url>%2F2012%2Fdiff-slice-substring-substr-from-their-arguments%2F</url>
      <content type="text"><![CDATA[JavaScript 字符串有三个方法用于截取部分内容，分别是：slice, substring, substr。这里通过参数的角度来区分这三个函数的不同与相同。 函数 sliceslice 函数接收的两个参数有如下的特点： 一个半闭半开区间的两个端点，并且参数可为负数； 第二个参数可选，默认为字符串的长度； 函数返回一个新的 这个区间之间的子字符串 12345678910var s = 'string';// 方法调用s.slice(start, end);// 参数是半开半闭区间的两个端点[ start &gt;= 0 ? start : s.length + start, isNaN(end) ? s.length : (end &gt;= 0 ? end : s.length + end)) 函数 slice 的模拟实现123456789101112131415161718192021222324252627282930313233343536373839// 随机生成8位字符串function generateString()&#123; return parseInt( Math.random() * 1E8).toString();&#125;// 随机生成一位数字function generatePoint()&#123; return parseInt( Math.random() * 10 );&#125;// slice实现function sliceDescription(start, end)&#123; if (isNaN(start)) &#123; return; &#125; var s = generateString(); // end默认为字符串的长度 end = end == undefined ? s.length : end; var result1 = s.slice(start, end); // slice方法的实现 var result2 = ''; start = start &gt;= 0 ? start : s.length + start; end = isNaN(end) ? s.length : (end &gt;= 0 ? end : s.length + end); var length = (end &gt; s.length ? s.length : end) - start; for (var i = 0; i &lt; length; i++) &#123; result2 += s[start + i]; &#125; console.log(result1 == result2);&#125;// 循环10000次，随机取start和endfor (var i = 0; i &lt; 1E4; i++) &#123; var start = generatePoint(); var end = generatePoint(); sliceDescription(start, end);&#125; 函数 substringsubstring 函数接收的两个参数有如下的特点： 接收两个参数，两个参数同样是一个半闭半开区间的端点值，与 slice 不同的是参数必须大于 0； 函数是取 from, to 之间较小的值作为截取起点 第二个参数可选，默认为字符串的长度； 函数返回一个新的 from 到 to 之间的子字符串 1234567s.substring(from, to);// 参数的表示[ Math.min(from, to), Math.max(from, to)) 函数 substring 的模拟实现12345678910111213141516171819202122232425262728293031323334353637383940// 随机生成8位字符串function generateString()&#123; return parseInt( Math.random() * 1E8).toString();&#125;// 随机生成一位数字function generatePoint()&#123; return parseInt( Math.random() * 10 );&#125;function substringDescription(from, to)&#123; if ( isNaN(from) ) &#123; return; &#125; var s = generateString(); var result1 = s.substring(from, to); if (from &lt; 0 || to &lt; 0) &#123; return; &#125; // substring的实现 var fromNew = Math.min(from, to); var toNew = Math.max(from, to); var result2 = ''; var length = (toNew &gt;= s.length ? s.length : toNew ) - fromNew; for (var i = 0; i &lt; length; i++) &#123; result2 += s[fromNew + i]; &#125; console.log( result1 == result2 );&#125;// 调用10000次，比对结果for (var i = 0; i &lt; 1E4; i++) &#123; var from = generatePoint(); var to = generatePoint(); substringDescription(from, to);&#125; 函数 substr函数 substr 接收两个参数：起点和截取长度。实际上， substr 是另外两个函数的一个变形。 123456// 调用方式：s.substr(start, length);// 等价于s.slice(start, start + length)s.substring(start, start + length) 最后，需要注意的是，substr 并为被纳入 ECMAScript 标准。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavasSript Prototype对象的初始值]]></title>
      <url>%2F2012%2Finitial-value-of-prototype-in-javascript%2F</url>
      <content type="text"><![CDATA[Javascript prototype的初始值在Object-Oriented Javascript 这本书第五章中提到： prototype is a property that gets created as soon as you define the function.It’s initial value is a empty object 这句话应该是错误的。prototype的初始值并不是一个空的对象，而是包含了constructor这个属性，值既指向构造函数： 12function Func()&#123;&#125;console.log(Func.prototype.hasOwnProperty('constructor')); // 输出true` 这样，后面的Own Properties versus prototype Properties小节的代码才能够说的通： 12newtoy.constructor // 输出Gadget(name, color)newtoy.constructor.prototype.constructor // 输出Gadget(name, color) Gadget.prototype是一个普通的对象，那么这个对象的constructor默认应该是指向Object()；然而因为prototype拥有一个constructor的自身属性，也就是prototype.hasOwnProperty(&#39;constructor&#39;)为true，从而覆盖掉由继承而来的constructor值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 中的 undefined]]></title>
      <url>%2F2012%2Fundefined-in-javascript%2F</url>
      <content type="text"><![CDATA[JavaScript 的 undefined 是个非常有趣的东西。 首先，undefined 在 JavaScript 里面是一种原始类型，并且类型有且仅有一个值，就是 undefined； 其次，JavaScript 在全局范围定义了一个变量，这个变量的值是 undefined，他的名字也是 undefined。 undefined 的不确定性但是这个全局变量并非一个常量，也不是一个保留字。也就是说，这个值是可以被更改，所以这个语句完全是有效的： 1undefined = "something else"; 由于 undefined 的不确定性，所以需要判断一个变量是否是 undefined 的时候不能直接使用如下语句： 123if (o.abc === undefined) &#123; // do something&#125; 使用技巧常见的更为可靠的方法有：使用 typeof操作符、void 操作符、函数形参。typeof 操作符返回操作数的类型（字符串），若操作数是 undefined 类型，那么返回 “undefined”，使用方法如下： 1typeof variable === "undefined"; void 操作符执行表达式并返回 undefined： 123function isUndefined(obj) &#123; return obj === void 0;&#125; 在 JavaScript 中，当函数的形参的个数多于实际传入的参数时，多余部分的形参的值将设成 undefined。故可通过此方法来确定 undefined。 12345(functon abc(root, undefined) &#123; if (root.abc === undefined) &#123; // do something &#125;&#125;(this));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 的函数声明]]></title>
      <url>%2F2012%2Fdeclare-functions-in-javascript%2F</url>
      <content type="text"><![CDATA[使用 function 关键字声明函数 1function foo()&#123;&#125; 使用 函数表达式 声明函数 1var bar = function()&#123;&#125; 使用 Function构造函数 声明函数 1var foobar = Function('arg1', 'arg2', 'function body')]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Detecting support of local storage]]></title>
      <url>%2F2011%2Fdetecting-support-of-local-storage%2F</url>
      <content type="text"><![CDATA[1234567891011121314function LocalStorage()&#123;&#125;extend(LocalStorage.prototype, &#123; isSupportCookie : function()&#123; return navigator.cookieEnabled; &#125;, isSupportUserData : function()&#123; var t = document.createElement('input'); return (typeof t.addBehavior !== 'undefined'); &#125;, isSupportDOMStorage : function()&#123; return (typeof window.localStorage !== 'undefined'); &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[特性检测 IE9 及以下的 IE 浏览器]]></title>
      <url>%2F2011%2Fdetecting-ie-browsers-below-versio-9-by-features%2F</url>
      <content type="text"><![CDATA[根据 border-radius css3 属性（或者其他未被 IE9 支持的属性）来判断： 1234var isLt9 = function()&#123; return document.all &amp;&amp; typeof document.body.style.borderRadius === 'undefined';&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[根据浏览器特性判断 IE7 浏览器]]></title>
      <url>%2F2011%2Fdetecting-ie7-by-features%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425function isIE() &#123; return document.all ? true : false;&#125;function isIE6() &#123; return typeof document.body.style.maxHeight === 'undefined';&#125;function isIE7()&#123; if ( !isIE() || isIE6() ) &#123; return false; &#125; else &#123; var xDocumentMode = document.documentMode; var isVersion7 = navigator.appVersion.indexOf('MSIE 7.') &gt; -1; if (isVersion7) &#123; // 检测是否支持 documentMode // 或 documentMode === 7 // IE8兼容性视图 / IE9 下 X-UA-Compatible 为 EmulateIE7,IE7 return xDocumentMode === 7 || !xDocumentMode; &#125; return false; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Understanding Compatibility Modes in Internet Explorer 8]]></title>
      <url>%2F2011%2Funderstanding-compatibility-modes-in-internet-explorer-8%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS Expression]]></title>
      <url>%2F2011%2FCSS-Expression%2F</url>
      <content type="text"><![CDATA[CSS Expression简述CSS Expression 是微软的专有技术，只有 Windows 下的 IE 浏览器支持，其他浏览器均对 expression 表达式不识别。 受影响的浏览器IE6 IE7 IE8(Q)。IE8 标准模式已不再支持 CSS Expression 常用场景 max-width, max-height等 position:fixed]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Detecting IE6 using features]]></title>
      <url>%2F2011%2Fdetecting-ie6-using-features%2F</url>
      <content type="text"><![CDATA[通过判断 body.style.maxHeight（IE7开始支持 max-width, max-height）： 12345if (typeof document.body.style.maxHeight !== 'undefined') &#123; // IE7+, Mozilla, safari, Opera&#125; else &#123; // IE6-&#125; 或者判断 window.XMLHttpRequest 对象： 12345if (window.XMLHttpRequest) &#123; // IE7+, Mozilla, safari, Opera&#125; else &#123; // IE6-&#125; 除此两个使用特性做检测的方法外，还有条件注释等方法。应用场景比如：置顶工具条或者其他固定位置的元素（position:fixed） 参考资料： Detecting IE7+ in JavaScript - Ajaxian]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Best practice: escape, or encodeURI / encodeURIComponent]]></title>
      <url>%2F2011%2Fbest-practice-escape-or-encodeuri-encodeuricomponent%2F</url>
      <content type="text"><![CDATA[关于 JavaScript 中的 escape、encodeURI、encodeURIComponent 三个函数，答案一针见血。另外，底下的其他回复也很有参考价值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apache Ant 中的条件 target]]></title>
      <url>%2F2011%2Fconditional-target-in-apache-ant%2F</url>
      <content type="text"><![CDATA[target 拥有 if/unless 属性，可以按照一定条件来选择是否执行 target。 结合 property 来说，if/unless 只能判断变量是否存在，而不能判断 property 的值。所以，以下的 target 输出同样的内容： 123456789&lt;property name="switch.lint.on" value="true" /&gt;&lt;target if="switch.lint.on"&gt; &lt;echo&gt; skip lint task &lt;/echo&gt;&lt;target&gt;&lt;property name="switch.lint.on" value="false" /&gt;&lt;target if="switch.lint.on"&gt; &lt;echo&gt; skip lint task &lt;/echo&gt;&lt;target&gt; 若要判断 property 得值是否与某个值相等，就需要使用 condition： 1234567&lt;condition property="switch.lint.on"&gt; &lt;equals arg1="$&#123;switch.lint&#125;" arg2="true" /&gt;&lt;condition&gt;&lt;target if="switch.lint.on"&gt; &lt;echo&gt; skip lint task &lt;/echo&gt;&lt;target&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mustache]]></title>
      <url>%2F2011%2Fmustache%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[设置Apache Ant property 的默认值]]></title>
      <url>%2F2011%2Fproperty-default-value-in-apache-ant%2F</url>
      <content type="text"><![CDATA[在ant下实现可选参数，首先想到的一个方法是使用condition task： 123&lt;condition name="dir.source" value="someValue" else="defaultValue" /&gt; &lt;isset property="dir.source" /&gt;&lt;/condition&gt; 当ant -v时，注意到关于property设置的内容： 1Override ignored for property "dir.source" 也就是说，property在设置之后，他的值是不能更改的，所以，没有必要使用condition或者if之类的去判断，直接定义默认的值就OK: 1&lt;property name="dir.source" value="defaultValue" /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery Plugin Boilerplate]]></title>
      <url>%2F2011%2Fjquery-plugin-boilerplate%2F</url>
      <content type="text"><![CDATA[1234567(function(window, $, undefined)&#123; $.fn.kmSlide = function(sDirection, iOffset, iDelay)&#123; return this.each(function()&#123; // Magic &#125;); &#125;;&#125;)(window, jQuery);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Git中执行类似Subversion中的项目导出]]></title>
      <url>%2F2011%2Fexport-projects-like-subversion-in-git%2F</url>
      <content type="text"><![CDATA[Git 仓库的信息存放在项目根目录的 .git 目录下，手动导出仅需将项目复制一份，然后删除 .git 目录即可。如果是要做批量或自动生成处理，git archive 命令就可以派上用场： 123git archive --format zip --output /full/path/to/zipfile.zip mastergit archive master | tar -x -C /somewhere/elsegit archive master | bzip2 &gt;source-tree.tar.bz2&lt;/code&gt;&lt;/pre&gt; 参考： How to do a “git export” git archive]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Import an Apache ant project]]></title>
      <url>%2F2011%2Fimport-an-apache-ant-project%2F</url>
      <content type="text"><![CDATA[使用 import 与 antcall task。 注：import 进来的任务，就算位置是在子目录，但是使用的 basedir 跟当前的 project 一样。 1234567891011&lt;!-- Path to Css Compressor--&gt;&lt;import file="$&#123;basedir&#125;/CompressorCss/build.xml" as="CompressorCss"/&gt;&lt;!--invoke the target in the imported file--&gt;&lt;target name="CompressCss"&gt; &lt;antcall target="CompressorCss.run"&gt; &lt;param name="dir.source" value="$&#123;basedir&#125;/source" /&gt; &lt;param name="dir.output" value="$&#123;basedir&#125;/output" /&gt; &lt;param name="dest.filename" value="test2" /&gt; &lt;/antcall&gt;&lt;/target&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS hacks for IE browsers]]></title>
      <url>%2F2011%2FCSS-hacks-for-IE-browsers%2F</url>
      <content type="text"><![CDATA[1234567.test&#123; color:green; color:red\9; /* All IE */ color:blue\0/; /* IE8 &amp; IE9 */ *color: #000; /* lte IE7 */ _color: #ccc; /* IE6 */&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maximum value of z-index]]></title>
      <url>%2F2011%2Fmaximum-value-of-z-index%2F</url>
      <content type="text"><![CDATA[Browser Max z-index value When exceeded, value changes to: Internet Explorer 6 2147483647 2147483647 Internet Explorer 7 2147483647 2147483647 Internet Explorer 8 2147483647 2147483647 Firefox 2 2147483647 element disappears Firefox 3 2147483647 0 Safari 3 16777271 16777271 Safari 4 2147483647 2147483647 Opera 9 2147483647 2147483647]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vundle Vim plugin manager]]></title>
      <url>%2F2011%2Fvundle-vim-plugin-manager%2F</url>
      <content type="text"><![CDATA[Vundle Setup Vundle1$ git clone http://github.com/gmarik/vundle.git ~/.vim/bundle/vundle Sample Config12345678910111213141516171819202122232425262728293031323334set nocompatible " be iMprovedfiletype off " required!set rtp+=~/.vim/bundle/vundle/call vundle#rc()" let Vundle manage Vundle" required! Bundle 'gmarik/vundle'" My Bundles here:"" original repos on githubBundle 'tpope/vim-fugitive'Bundle 'Lokaltog/vim-easymotion'Bundle 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;" vim-scripts reposBundle 'L9'Bundle 'FuzzyFinder'Bundle 'rails.vim'" non github reposBundle 'git://git.wincent.com/command-t.git'" ...filetype plugin indent on " required! "" Brief help" :BundleList - list configured bundles" :BundleInstall(!) - install(update) bundles" :BundleSearch(!) foo - search(or refresh cache first) for foo" :BundleClean(!) - confirm(or auto-approve) removal of unused bundles"" see :h vundle for more details or wiki for FAQ" NOTE: comments after Bundle command are not allowed..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重装Homebrew]]></title>
      <url>%2F2011%2Freinstall-homebrew%2F</url>
      <content type="text"><![CDATA[卸载当前版本 12345cd `brew —-prefix`rm -rf Cellarbrew prunerm -rf Library .git .gitignore bin/brew README.md share/man/man1/brewrm -rf ~/Library/Caches/Homebrew 安装新版本 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.github.com/gist/323731)&quot;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[根据 UserAgent 做页面跳转]]></title>
      <url>%2F2011%2Fredirect-by-user-agent%2F</url>
      <content type="text"><![CDATA[1234567891011121314(function(window, undefined) &#123; 'use strict'; var keywords = [ 'iPod', 'iPhone', 'Android', 'Opera Mini', 'BlackBerry', 'webOS', 'UCWEB', 'Blazer', 'PSP', 'IEMobile', 'Symbian' ].join('|'); var pa = new RegExp(keywords, 'g'); if ( pa.test(window.navigator) ) &#123; window.location.href = 'http://m.example.com'; &#125;&#125;)(window);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Strict Mode]]></title>
      <url>%2F2011%2Fstrict-mode%2F</url>
      <content type="text"><![CDATA[MDN - Strict Mode John Resig - ECMAScript 5 Strict Mode JSON and more]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSDoc toolkit]]></title>
      <url>%2F2011%2Fjsdoc-toolkit%2F</url>
      <content type="text"><![CDATA[Version2 Version3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 中判断对象是否为空]]></title>
      <url>%2F2011%2Fdetect-if-object-is-empty-in-javascript%2F</url>
      <content type="text"><![CDATA[判断 JavaScript 对象是否是一个空的对象，可以遍历对象。若对象拥有任意的实例属性，则对象非空。 123456789101112/** * Is #obj empty? * @param &#123;Object&#125; obj object to be detected. */function isEmptyObject(obj) &#123; for (var prop in obj) &#123; if (obj.hasOwnProperty(prop)) &#123; return false; &#125; &#125; return true;&#125; 若 ECMAScript 5 的 Object.keys 可用，则可以判断 Object.keys 返回数组的长度： 1234567function isEmptyObject(obj) &#123; if (typeof Object.keys === "function") &#123; return Object.keys(obj).length === 0; &#125; else &#123; // 遍历对象 &#125;&#125; 参考资料： How do I test for an empty Javascript object from JSON?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 构造函数的返回值]]></title>
      <url>%2F2011%2Freturn-value-of-a-construction-in-javascript%2F</url>
      <content type="text"><![CDATA[当使用 new 操作符调用构造函数时，构造函数的内部属性 [[Construct]] 属性将被调用。这个属性定义在 ECMA-262 3rd Edition 的 [[Construct]]部分。 构造函数 F 的内部属性 [[Construct]] 被调用时，以下步骤将会执行： 创建 一个原生的 ECMAScript 对象，记为 o； 设定 o 的 [[Class]] 属性为 “Object”，即 o.Class = “Object”； 获取 F 的 prototype 属性的值，记为 Fp ； 若 Fp 是一个对象，设定 o 的 [[Prototype]] 属性为 Fp，即 o.Prototype = Fp； 若 Fp 不是一个对象，设定 o 的 [[Prototype]] 属性为 Object prototype 的值。 调用 F 的 [[Call]] 属性。将 o 作为 this 的值，传入 [[Construct]] 的参数作为参数，即 F.call(o, arguments)，执行结果 记为 Fc 若 Fc 是一个对象， 那么返回 Fc； 返回 o 从第 7 步可以看到，当构造函数F执行后的返回值是一个对象时，new F() 的值即为返回的对象： 123456789101112function ConstructorReturnObject()&#123; this.test = "test"; return new String("testString");&#125;var t2 = new ConstructorReturnObject();// t2 并没有 test 属性console.log(t2.test); // undefined// t2的类型是 String// 输出 [object String]console.log(Object.prototype.toString.call(t2)); 当构造函数 F 执行的返回值类型非对象时，new F() 即返回 this： 12345678function ConstructorReturnNonObjectValue() &#123; this.test = "test"; return "testString";&#125;var t1 = new ConstructorReturnNonObjectValue();// 输出 &#123;test: "test"&#125;console.log(t1); 参考资料： What values can a constructor return to avoid returning this [[Construct]]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Useful CSS Snippets]]></title>
      <url>%2F2011%2Fuseful-css-snippets%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web Beacon]]></title>
      <url>%2F2011%2Fweb-beacon%2F</url>
      <content type="text"><![CDATA[123window.onbeforeunload = function()&#123; (new Image()).src = 'http://ex.iissnan.com/event.do?data=' + sData;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Essential JavaScript Namespacing Patterns]]></title>
      <url>%2F2011%2Fessential-javascript-namespacing-patterns%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[IE6 flicker fix]]></title>
      <url>%2F2011%2Fie6-flicker-fix%2F</url>
      <content type="text"><![CDATA[IE6 flicker Fix 通过 CSS 修复123html &#123; filter: expression(document.execCommand("BackgroundImageCache", false, true));&#125; 通过 JavaScript 修复123try &#123; document.execCommand('BackgroundImageCache', false, true);&#125; catch(e) &#123;&#125;; 更改客户端设置12Tools &gt; Internet Options &gt; Temporary Internet files &gt; Settings选择Automatically，确定]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[!important 引起 IE 下 JavaScript 脚本报参数无效]]></title>
      <url>%2F2011%2Fimportant-rules-cause-errors-in-ie%2F</url>
      <content type="text"><![CDATA[IE6 - IE9 皆会报参数无效： 1oElem.style.width = '200px !important'; 或者 1jQuery('#sElem').css(&#123;'width' : '200px !important'&#125;); 覆盖样式里面已经写有 !important 的规则，目前了解的方法只有通过元素的 cssText 来设置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Anonymous function in JavaScript]]></title>
      <url>%2F2011%2Fanounymous-function-in-javascript%2F</url>
      <content type="text"><![CDATA[常见的写法： 123(function()&#123; // do something magic...&#125;)(); JSLint 建议的写法： 123(function()&#123; // do something magic...&#125;());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript style guidelines]]></title>
      <url>%2F2011%2Fjavascript-style-guidelines%2F</url>
      <content type="text"><![CDATA[两份JavaScript代码风格指南： jQuery Core Style Guidlines Google JavaScript Style Guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[就算是MacOSX，也是要瞎搞一番才会顺手的]]></title>
      <url>%2F2011%2Fmy-software-stack-for-new-mac-os-x%2F</url>
      <content type="text"><![CDATA[工具列表 （按照安装顺序）： Git-osx-install Homebrew - Mac OSX 的包管理 1ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; XCode 命令工具 wget 1brew install wget 有时遇到默认的下载链接速度十分坑爹，就 brew edit wget 修改下链接再装 Oh-my-zsh。执行脚本： 1wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Inspect :hover Style of Element in Chrome Developer Tool]]></title>
      <url>%2F2011%2Finspect-hover-style-of-elements-in-google-chrome%2F</url>
      <content type="text"><![CDATA[Quora上Question，这么做： Right click the element while hovering over it, then (without moving your cursor) use the keyboard to navigate the context-menu and select “Inspect element”. Hit enter, and you’ll see the hover styles. Stack Overflow上Question，这个Bug已fixed，更新到dev channel版本的Google Chrome里面可以看到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OSX 的剪切快捷键]]></title>
      <url>%2F2011%2Fcut-and-paste-in-mac-os-x%2F</url>
      <content type="text"><![CDATA[复制： Command + c 剪切到： Option + Command + v]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IE 下 iframe 存取 cookie]]></title>
      <url>%2F2011%2Fmanipulate-cookie-in-iframes-of-ie%2F</url>
      <content type="text"><![CDATA[IE6 后引入了 P3P。 解决方法：在回应的 HTTP HEADER 中输出 P3P，比如在 PHP 中： 1header('P3P: CP=CAO PSA OUR');]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[insertBefore]]></title>
      <url>%2F2011%2Finsertbefore%2F</url>
      <content type="text"><![CDATA[insertBefore() 方法可在已有的子节点前插入一个新的子节点。此方法可返回新的子节点。 1insertBefore(newchild, refchild); 在 IE 中如果没有 refchild，那么 insertBefore() 方法第二个参数不要指定。而在 Firefox/Google Chrome 等需要设定为 null。 考虑往列表 ul中插入列表项 li： 12345678var firstItem = ul.childNodes[0];// 判断ul是否存在子元素if (!firstItem) &#123; document.all ? oUl.insertBefore(li) : ul.insertBefore(li, null);&#125; else &#123; ul.insertBefore(li, firstItem);&#125; 参考资料： insertBefore Method - MSDN]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Using jQuery to test if an input is focus]]></title>
      <url>%2F2011%2Fusing-jquery-to-test-if-an-input-is-focus%2F</url>
      <content type="text"><![CDATA[Using jQuery to test if an input has focus - StackOverflow jQuery 1.6+jQuery added a :focus selector so we no longer need to add it ourselves… 1return $('elem').is(':focus') ? true : false; jQuery 1.5 and below123jQuery.expr[':'].focus = function( elem ) &#123; return elem === document.activeElement &amp;&amp; (elem.type || elem.href);&#125;; Any version of jQueryIf you just want to figure out which element has focus, you can use $(document.activeElement); If you aren’t sure if the version will be 1.6 or lower, you can add the :focus selector if it is missing: 123456789(function ($) &#123; var filters = $.expr[":"]; if (!filters.focus) &#123; filters.focus = function( elem ) &#123; return elem === document.activeElement &amp;&amp; (elem.type || elem.href); &#125;; &#125;&#125;)(jQuery);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 JavaScript 更改具有 !important 声明的样式规则]]></title>
      <url>%2F2011%2Fupdate-rules-with-important-declaration-using-javascript%2F</url>
      <content type="text"><![CDATA[如果在 CSS 中使用 !important 属性声明规则，那么在 JavaScript 中需要使用 cssText 属性对样式进行修改。 如果元素仅有一条规则，可以直接将新规则（带 !important 声明）复制给 cssText： 1element.style.cssText = 'display:inline !important'; 如果元素具备多条规则，则需要将新规则加到 cssText 中： 1element.style.cssText += 'display:inline !important'; 参考资料： Overriding !important style using Javascript]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[特性判断 IE 浏览器]]></title>
      <url>%2F2011%2Fdetecting-ie-by-browser-features%2F</url>
      <content type="text"><![CDATA[一、使用 document.all 123function isIE()&#123; return document.all ? true : false;&#125; 二、判断 window.ActiveXObject 123function isIE()&#123; return !!window.ActiveXObject ? true : false;&#125; 三、判断 currentStyle，得排除 Opera 浏览器 123function isIE()&#123; return (document.body.currentStyle &amp;&amp; !window.opera) ? true : false;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apache Ant]]></title>
      <url>%2F2011%2Fapache-ant%2F</url>
      <content type="text"><![CDATA[Apache Ant [2011-08-24] OSX comes with ant [2011-08-27] 一份简单的构建文件（build.xml） 123456&lt;?xml version="1.0" ?&gt;&lt;project name="ant-hello-world" default="init" basedir="."&gt; &lt;target name="init"&gt; &lt;echo&gt;Hello World!&lt;/echo&gt; &lt;/target&gt;&lt;project&gt; [2011-09-15]合并文件 - Task concat 12345678&lt;target name="js-concat"&gt; &lt;concat destfile="$&#123;web.dir&#125;/js/script.js" encoding="UTF-8"&gt; &lt;header trimleading="yes"&gt;(function()&#123; &lt;/header&gt; &lt;filelist dir="$&#123;web.dir&#125;/js" files="jquery.js, form.js, animate.js, analytics.js" /&gt; &lt;footer&gt;&#125;)();&lt;/footer&gt; &lt;/concat&gt;&lt;/target&gt; [2011-09-15]JsLint (Jslint4java) 1234567891011&lt;!--JSLint--&gt;&lt;taskdef name="jslint" classname="com.googlecode.jslint4java.ant.JSLintTask" classpath="$&#123;lib.dir&#125;/jslint4java-2.0.0.jar" /&gt;&lt;target name="js-lint"&gt; &lt;jslint&gt; &lt;formatter type="plain" /&gt; &lt;fileset dir="$&#123;web.dir&#125;/js" includes="form.js, animate.js" /&gt; &lt;/jslint&gt;&lt;/target&gt; [2011-09-16]Compress JS Using Google Compiler Closure 1234567891011121314&lt;!--Compress JS Using Google Compiler Closure--&gt;&lt;target name="JS-Compress"&gt; &lt;property name="google.compressor" value="$&#123;lib.dir&#125;/compiler.jar" /&gt; &lt;apply executable="java" dest="$&#123;web.dir&#125;/js"&gt; &lt;fileset dir="$&#123;web.dir&#125;/js" includes="think.js" /&gt; &lt;arg line="-jar" /&gt; &lt;arg path="$&#123;google.compressor&#125;" /&gt; &lt;arg line="--js" /&gt; &lt;srcfile /&gt; &lt;arg line="--js_output_file" /&gt; &lt;mapper type="glob" from="*.js" to="*-min.js" /&gt; &lt;targetfile /&gt; &lt;/apply&gt;&lt;/target&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[What happened to console.log in IE8]]></title>
      <url>%2F2011%2Fwhat-happened-to-console-log-in-ie8%2F</url>
      <content type="text"><![CDATA[在Internet Explorer 8中，如果没有打开Developer Toolbar，那么代码中调用console.log将会提示错误。一种避免方法是判断console以及console.log是否存在，若不存在则调用alert方法： 1234567function trace(s) &#123; if (this.console &amp;&amp; typeof console.log !== "undefined") &#123; console.log(s); &#125; else &#123; alert(s); &#125;&#125; 用try..catch简写为： 123function trace(s) &#123; try &#123; console.log(s) &#125; catch (e) &#123; alert(s) &#125;&#125; 参考资料： What happened to console.log in IE8? - Stack Overflow]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello, WordPress from Magician UIc's hat]]></title>
      <url>%2F2011%2Fhello-wordpress-from-magician-uic-s-hat%2F</url>
      <content type="text"><![CDATA[欢迎使用 WordPress。这是系统自动生成的演示文章。编辑或者删除它，然后开始您的博客！]]></content>
    </entry>

    
  
  
</search>
